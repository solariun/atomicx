<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_classthread_1_1atomicx" xml:lang="en-US">
<title>thread::atomicx Class Reference</title>
<indexterm><primary>thread::atomicx</primary></indexterm>
<para>
<computeroutput>#include &lt;atomicx.hpp&gt;</computeroutput>
</para>
<simplesect>
    <title>Data Structures    </title>
        <itemizedlist>
            <listitem><para>class <link linkend="_classthread_1_1atomicx_1_1aiterator">aiterator</link></para>
</listitem>
            <listitem><para>struct <link linkend="_structthread_1_1atomicx_1_1_message">Message</link></para>
</listitem>
            <listitem><para>class <link linkend="_classthread_1_1atomicx_1_1mutex">mutex</link></para>
</listitem>
            <listitem><para>class <link linkend="_classthread_1_1atomicx_1_1queue">queue</link></para>
</listitem>
            <listitem><para>class <link linkend="_classthread_1_1atomicx_1_1semaphore">semaphore</link></para>
</listitem>
            <listitem><para>class <link linkend="_classthread_1_1atomicx_1_1smart__ptr">smart_ptr</link></para>
</listitem>
            <listitem><para>class <link linkend="_classthread_1_1atomicx_1_1smart_mutex">smartMutex</link></para>

<para>RII compliance lock/shared lock to auto unlock on destruction. </para>
</listitem>
            <listitem><para>class <link linkend="_classthread_1_1atomicx_1_1smart_semaphore">smartSemaphore</link></para>
</listitem>
            <listitem><para>class <link linkend="_classthread_1_1atomicx_1_1_timeout">Timeout</link></para>

<para><link linkend="_classthread_1_1atomicx_1_1_timeout">Timeout</link> Check object. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Public Types    </title>
        <itemizedlist>
            <listitem><para>enum class <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007ed">aTypes</link> : uint8_t { 
<link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edaea2b2676c28c0db26d39331a336c6b92">start</link> =1
, <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007eda75101dcdfc88455bcafc9e53e0b06689">running</link> =5
, <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007eda97bc592b27a9ada2d9a4bb418ed0ebed">now</link> =6
, <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edaef399b2d446bb37b7c32ad2cc1b6045b">stop</link> =10
, 
<link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edadce7c4174ce9323904a934a486c41288">lock</link> =50
, <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007eda49256b9819abacbb8e6e031a03abe81b">wait</link> =55
, <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edab48b13e73a6ac2a86dc54425dd24d9ff">subscription</link> =60
, <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edac9fab33e9458412c527c3fe8a13ee37d">sleep</link> =100
, 
<link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edaefab200f4775c7a6f73743d4dcd6681a">stackOverflow</link> =255
 }</para>
</listitem>
            <listitem><para>enum class <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> : uint8_t { 
<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67facb5e100e5a9a3e7f6d1fd97512215282">error</link> =10
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa444bcb3a3fcf8389296c49467f27e1d6">ok</link>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa8c4291f6956da81515a5c0caec2976d0">look</link>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">wait</link>
, 
<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa90272dda245ae1fb3cf197e91a8689dc">timeout</link>
 }</para>
</listitem>
            <listitem><para>enum class <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> : uint8_t { <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">one</link> = 0
, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaa181a603769c1f98ad927e7367c7aa51">all</link> = 1
 }</para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Public Member Functions    </title>
        <itemizedlist>
            <listitem><para><link linkend="_classthread_1_1atomicx_1_1aiterator">aiterator</link> <link linkend="_classthread_1_1atomicx_1a0e188b4cdad5fb7f9fff7cd1e0f438aa">begin</link> (void)</para>

<para>Get the beggining of the list. </para>
</listitem>
            <listitem><para><link linkend="_classthread_1_1atomicx_1_1aiterator">aiterator</link> <link linkend="_classthread_1_1atomicx_1a8a832099edb224496c7ba204695138c7">end</link> (void)</para>

<para>Get the end of the list. </para>
</listitem>
            <listitem><para>virtual <link linkend="_classthread_1_1atomicx_1ac460ddbc6a7201689a762fb8d3c35397">~atomicx</link> (void)</para>

<para>virtual destructor of the atomicx </para>
</listitem>
            <listitem><para>size_t <link linkend="_classthread_1_1atomicx_1a75865402817f74f5917c958c2cc631ed">GetID</link> (void)</para>

<para>Get the current thread ID. </para>
</listitem>
            <listitem><para>size_t <link linkend="_classthread_1_1atomicx_1ad58b1b08bf0c0a3fe62affac1bffe845">GetStackSize</link> (void)</para>

<para>Get the Max Stack Size for the thread. </para>
</listitem>
            <listitem><para><link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> <link linkend="_classthread_1_1atomicx_1a075d951e2432e1e06f04691e3b83b2d5">GetNice</link> (void)</para>

<para>Get the Nice the current thread. </para>
</listitem>
            <listitem><para>size_t <link linkend="_classthread_1_1atomicx_1a5bdde2eddb025706719d11632b4450b7">GetUsedStackSize</link> (void)</para>

<para>Get the Used Stack Size for the thread since the last context change cycle. </para>
</listitem>
            <listitem><para><link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> <link linkend="_classthread_1_1atomicx_1ac357706436b933641d236447cdbd5462">GetCurrentTick</link> (void)</para>

<para>Get the Current Tick using the ported tick granularity function. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Static Public Member Functions    </title>
        <itemizedlist>
            <listitem><para>static <link linkend="_classthread_1_1atomicx">atomicx</link> * <link linkend="_classthread_1_1atomicx_1a0a73c90e27fec5dea704c430c36e0cee">GetCurrent</link> ()</para>

<para>Get the Current thread in execution. </para>
</listitem>
            <listitem><para>static bool <link linkend="_classthread_1_1atomicx_1a64de6117b863b3d2edd217798d9c27f4">Start</link> (void)</para>

<para>Once it is call the process blocks execution and start all threads. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>If GetName was not overloaded by the derived thread implementation    </title>

<para><anchor xml:id="__1amgrpa95e051fbacc0563045fd1e93905af10"/>Get the Name object</para>

<para><formalpara><title>Returns</title>

<para>const char* name in plain c string</para>
</formalpara>
a standard name will be returned. </para>
        <itemizedlist>
            <listitem><para>virtual const char * <link linkend="_classthread_1_1atomicx_1a06fba915b6d19dd927f28a7b88fa566b">GetName</link> (void)</para>
</listitem>
            <listitem><para><link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> <link linkend="_classthread_1_1atomicx_1a96d17265ebe39e32586b4e117c15ae68">GetTargetTime</link> (void)</para>

<para>Get next moment in ported tick granularity the thread will be due to return. </para>
</listitem>
            <listitem><para>int <link linkend="_classthread_1_1atomicx_1a59ff0db3d410d11672a4376432ec8188">GetStatus</link> (void)</para>

<para>Get the current thread status. </para>
</listitem>
            <listitem><para>int <link linkend="_classthread_1_1atomicx_1ab9b7e5c959deefbe1dfccab55233a0c7">GetSubStatus</link> (void)</para>

<para>Get the current thread sub status. </para>
</listitem>
            <listitem><para>size_t <link linkend="_classthread_1_1atomicx_1a238414e659cf1bd1ac7b79eae1de1d10">GetReferenceLock</link> (void)</para>

<para>Get the Reference Lock last used to lock the thread. </para>
</listitem>
            <listitem><para>size_t <link linkend="_classthread_1_1atomicx_1a080c7d232dece44e29b3858fd4f2ac8c">GetTagLock</link> (void)</para>

<para>Get the last tag message posted. </para>
</listitem>
            <listitem><para>void <link linkend="_classthread_1_1atomicx_1a6663c1d4f9483ee2b00ff01426efb6c7">SetNice</link> (<link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> nice)</para>

<para>Set the Nice of the thread. </para>
</listitem>
            <listitem><para>template&lt;typename T , size_t N&gt; </para><para><link linkend="_classthread_1_1atomicx_1a06c82de06faf2019a9af23bc75886baa">atomicx</link> (T(&amp;stack)[N])</para>

<para>Construct a new atomicx thread. </para>
</listitem>
            <listitem><para><link linkend="_classthread_1_1atomicx_1ae227c8a72cddade05625f906b56f2cb7">atomicx</link> (size_t nStackSize=0, int nStackIncreasePace=1)</para>

<para>Construct a new atomicx object and set initial auto stack and increase pace. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_classthread_1_1atomicx_1a8917ef300f396b3d8bc9fdd8aacccf14">run</link> (void) noexcept=0</para>

<para>The pure virtual function that runs the thread loop. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_classthread_1_1atomicx_1a8f358048df310da5b3f0b669605fc197">StackOverflowHandler</link> (void) noexcept=0</para>

<para>Handles the StackOverflow of the current thread. </para>
</listitem>
            <listitem><para>virtual void <link linkend="_classthread_1_1atomicx_1a641e79e24059fb3fcaf81ee54a2009be">finish</link> () noexcept</para>

<para>Called right after run returns, can be used to self-destroy the object and other maintenance actions. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1ae8d4a2b0d8f59ea33a59236d69034cc7">IsStackSelfManaged</link> (void)</para>

<para>Return if the current thread&apos;s stack memory is automatic. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1ab3dd1245396fc470b7b2c6a31a4455ca">Yield</link> (<link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> nSleep=<link linkend="_atomicx_8hpp_1a5f79904e0c0abe4f6120ed97f66b3802">ATOMICX_TIME_MAX</link>)</para>

<para>Foce the context change explicitly. </para>
</listitem>
            <listitem><para><link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> <link linkend="_classthread_1_1atomicx_1af7c7ea1f95881fbc140c2a8f4cbf3c2e">GetLastUserExecTime</link> ()</para>

<para>Get the Last Execution of User Code. </para>
</listitem>
            <listitem><para>size_t <link linkend="_classthread_1_1atomicx_1aee0a056b991664861eade9caf6adbd32">GetStackIncreasePace</link> (void)</para>

<para>Get the Stack Increase Pace value. </para>
</listitem>
            <listitem><para>void <link linkend="_classthread_1_1atomicx_1a8b38e8d84d71903a9162bcc541235614">YieldNow</link> (void)</para>

<para>Trigger a high priority NOW, caution it will always execute before normal yield. </para>
</listitem>
            <listitem><para>void <link linkend="_classthread_1_1atomicx_1aee21cbd30a48efbf3a55817ad9bfe3e3">SetDynamicNice</link> (bool status)</para>

<para>Set the Dynamic Nice on and off. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1ae80cbf9f8fc2617eaa168d1281225715">IsDynamicNiceOn</link> ()</para>

<para>Get Dynamic Nice status. </para>
</listitem>
            <listitem><para>uint32_t <link linkend="_classthread_1_1atomicx_1ab27f5a456d8983f5c17102bc0aaa0da0">GetTopicID</link> (const char *pszTopic, size_t nKeyLenght)</para>

<para>calculate the Topic ID for a given topic text </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>bool <link linkend="_classthread_1_1atomicx_1a3a7a1c5a1e645c09c0ff0a6c355404c5">LookForWaitings</link> (T &amp;refVar, size_t nTag, size_t hasAtleast, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitFor)</para>

<para>Sync with thread call for a wait (refVar,nTag) </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>bool <link linkend="_classthread_1_1atomicx_1af919d7337b1a6cc5912cd1c7c4fe5ea8">LookForWaitings</link> (T &amp;refVar, size_t nTag, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitFor)</para>

<para>Sync with thread call for a wait (refVar,nTag) </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>bool <link linkend="_classthread_1_1atomicx_1ad4512ab7de89d7cfd6b5d60c2d986b3e">IsWaiting</link> (T &amp;refVar, size_t nTag=0, size_t hasAtleast=1, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>Check if there are waiting threads for a given reference pointer and tag value. </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>size_t <link linkend="_classthread_1_1atomicx_1af86a54fe9571c2fbab03c9f62f453ad5">HasWaitings</link> (T &amp;refVar, size_t nTag=0, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>Report how much waiting threads for a given reference pointer and tag value are there. </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>bool <link linkend="_classthread_1_1atomicx_1a51434a435b3470ee885272a18e7838bb">Wait</link> (size_t &amp;nMessage, T &amp;refVar, size_t nTag=0, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitFor=0, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>Blocks/Waits a notification along with a message and tag from a specific reference pointer. </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>bool <link linkend="_classthread_1_1atomicx_1aae81685ea59341f64a4b3d8cc5886563">Wait</link> (T &amp;refVar, size_t nTag=0, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitFor=0, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>Blocks/Waits a notification along with a tag from a specific reference pointer. </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>size_t <link linkend="_classthread_1_1atomicx_1a1cb98240204ba7c5981ad9ffba095253">SafeNotify</link> (size_t &amp;nMessage, T &amp;refVar, size_t nTag=0, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll=<link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link>, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>Safely notify all Waits from a specific reference pointer along with a message without triggering context change. </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>size_t <link linkend="_classthread_1_1atomicx_1a8b3845a6f977e4fc9644e996d4102d75">Notify</link> (size_t &amp;nMessage, T &amp;refVar, size_t nTag=0, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll=<link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link>, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>Notify all Waits from a specific reference pointer along with a message and trigger context change if at least one wait thread got notified. </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>size_t <link linkend="_classthread_1_1atomicx_1a401db852c22e1982ae5c184ec93423c0">Notify</link> (size_t &amp;&amp;nMessage, T &amp;refVar, size_t nTag=0, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll=<link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link>, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>size_t <link linkend="_classthread_1_1atomicx_1a91a943d6b7dbce240fb8bc611edead6b">SyncNotify</link> (size_t &amp;nMessage, T &amp;refVar, size_t nTag=0, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitForWaitings=0, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll=<link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link>, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>SYNC Waits for at least one Wait call for a given reference pointer along with a message and trigger context change. </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>size_t <link linkend="_classthread_1_1atomicx_1a7e4e0bf42bafa19be930b43b72d244f7">SyncNotify</link> (size_t &amp;&amp;nMessage, T &amp;refVar, size_t nTag=0, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitForWaitings=0, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll=<link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link>, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>size_t <link linkend="_classthread_1_1atomicx_1a3658882cb26cc60166bf7b29a7024d14">SafeNotify</link> (T &amp;refVar, size_t nTag=0, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll=<link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link>, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>Safely notify all Waits from a specific reference pointer without triggering context change. </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>size_t <link linkend="_classthread_1_1atomicx_1aad548d78d129a70a9e68862e06d4db9d">SyncNotify</link> (T &amp;refVar, size_t nTag, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitForWaitings=0, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll=<link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link>, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>SYNC Waits for at least one Wait call for a given reference pointer and trigger context change. </para>
</listitem>
            <listitem><para>template&lt;typename T &gt; </para><para>size_t <link linkend="_classthread_1_1atomicx_1ad1d6b634c9c90c1c15acc391f2b97671">Notify</link> (T &amp;refVar, size_t nTag=0, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll=<link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link>, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType=<link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link>)</para>

<para>Notify all Waits from a specific reference pointer and trigger context change if at least one wait thread got notified. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1a407be004173a7db41834eb58fb8f4436">WaitBrokerMessage</link> (const char *pszKey, size_t nKeyLenght, <link linkend="_structthread_1_1atomicx_1_1_message">Message</link> &amp;message)</para>

<para>Block and wait for message from a specific topic string. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1a1cfdab652a4a90fa8c760d9ee3a802fb">WaitBrokerMessage</link> (const char *pszKey, size_t nKeyLenght)</para>

<para>Block and wait for a notification from a specific topic string. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1afc67058a34cd39f3f853a7f9a2ae84fd">Publish</link> (const char *pszKey, size_t nKeyLenght, const <link linkend="_structthread_1_1atomicx_1_1_message">Message</link> message)</para>

<para>Publish a message for a specific topic string and trigger a context change if any delivered. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1a5b238f8831ae0cb3a53c685123e5a5d8">SafePublish</link> (const char *pszKey, size_t nKeyLenght, const <link linkend="_structthread_1_1atomicx_1_1_message">Message</link> message)</para>

<para>Safely Publish a message for a specific topic string DO NOT trigger a context change if any delivered. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1a686358de14f2be34e688ee22dd5bc5b8">Publish</link> (const char *pszKey, size_t nKeyLenght)</para>

<para>Publish a notification for a specific topic string and trigger a context change if any delivered. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1a4877838c0c1e38a7941f7ca86926ada9">SafePublish</link> (const char *pszKey, size_t nKeyLenght)</para>

<para>Safely Publish a notification for a specific topic string DO NOT trigger a context change if any delivered. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1ab6b7c287310a686e589c57947084124b">HasSubscriptions</link> (const char *pszTopic, size_t nKeyLenght)</para>

<para>Check if there is subscryption for a specific Topic String. </para>
</listitem>
            <listitem><para>bool <link linkend="_classthread_1_1atomicx_1ad335842d925985e2ea56639c5eda0f22">HasSubscriptions</link> (uint32_t nKeyID)</para>

<para>Check if there is subscryption for a specific Topic ID. </para>
</listitem>
            <listitem><para>virtual bool <link linkend="_classthread_1_1atomicx_1ae43c2d0de94878ce0602a3b40d4deeba">BrokerHandler</link> (const char *pszKey, size_t nKeyLenght, <link linkend="_structthread_1_1atomicx_1_1_message">Message</link> &amp;message)</para>

<para>Default broker handler for a subscribed message. </para>
</listitem>
            <listitem><para>virtual bool <link linkend="_classthread_1_1atomicx_1a2407946fa015153b0a813d9ea7d15019">IsSubscribed</link> (const char *pszKey, size_t nKeyLenght)</para>

<para>Specialize and gives power to decide if a topic is subscrybed on not. </para>
</listitem>
            <listitem><para>void <link linkend="_classthread_1_1atomicx_1acfdf080727d53cbaf31cd6b8c6595e5b">SetStackIncreasePace</link> (size_t nIncreasePace)</para>

<para>Set the Stack Increase Pace object. </para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Member Enumeration Documentation</title>
<anchor xml:id="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f"/><section>
    <title>aSubTypes</title>
<indexterm><primary>aSubTypes</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>aSubTypes</secondary></indexterm>
<para><computeroutput>enum class <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">thread::atomicx::aSubTypes</link> : uint8_t<computeroutput>[strong]</computeroutput></computeroutput></para><informaltable frame="all">
<title>Enumerator</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<tbody>
<row><entry><indexterm><primary>error</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>error</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67facb5e100e5a9a3e7f6d1fd97512215282"/>error</entry><entry></entry></row><row><entry><indexterm><primary>ok</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>ok</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa444bcb3a3fcf8389296c49467f27e1d6"/>ok</entry><entry></entry></row><row><entry><indexterm><primary>look</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>look</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa8c4291f6956da81515a5c0caec2976d0"/>look</entry><entry></entry></row><row><entry><indexterm><primary>wait</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>wait</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b"/>wait</entry><entry></entry></row><row><entry><indexterm><primary>timeout</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>timeout</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa90272dda245ae1fb3cf197e91a8689dc"/>timeout</entry><entry></entry></row>    </tbody>
    </tgroup>
</informaltable>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007ed"/><section>
    <title>aTypes</title>
<indexterm><primary>aTypes</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>aTypes</secondary></indexterm>
<para><computeroutput>enum class <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007ed">thread::atomicx::aTypes</link> : uint8_t<computeroutput>[strong]</computeroutput></computeroutput></para>
<para><informaltable frame='bottom'><tgroup cols='1'><colspec align='center'/><tbody><row><entry align='center'>
</entry></row></tbody></tgroup></informaltable>
 </para>
<section xml:id="_classthread_1_1atomicx_1autotoc_md1">
<title>STATE MACHINE TYPES</title>
</section>
<informaltable frame="all">
<title>Enumerator</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<tbody>
<row><entry><indexterm><primary>start</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>start</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edaea2b2676c28c0db26d39331a336c6b92"/>start</entry><entry></entry></row><row><entry><indexterm><primary>running</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>running</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007eda75101dcdfc88455bcafc9e53e0b06689"/>running</entry><entry></entry></row><row><entry><indexterm><primary>now</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>now</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007eda97bc592b27a9ada2d9a4bb418ed0ebed"/>now</entry><entry></entry></row><row><entry><indexterm><primary>stop</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>stop</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edaef399b2d446bb37b7c32ad2cc1b6045b"/>stop</entry><entry></entry></row><row><entry><indexterm><primary>lock</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>lock</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edadce7c4174ce9323904a934a486c41288"/>lock</entry><entry></entry></row><row><entry><indexterm><primary>wait</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>wait</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007eda49256b9819abacbb8e6e031a03abe81b"/>wait</entry><entry></entry></row><row><entry><indexterm><primary>subscription</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>subscription</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edab48b13e73a6ac2a86dc54425dd24d9ff"/>subscription</entry><entry></entry></row><row><entry><indexterm><primary>sleep</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>sleep</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edac9fab33e9458412c527c3fe8a13ee37d"/>sleep</entry><entry></entry></row><row><entry><indexterm><primary>stackOverflow</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>stackOverflow</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007edaefab200f4775c7a6f73743d4dcd6681a"/>stackOverflow</entry><entry></entry></row>    </tbody>
    </tgroup>
</informaltable>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab"/><section>
    <title>NotifyType</title>
<indexterm><primary>NotifyType</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>NotifyType</secondary></indexterm>
<para><computeroutput>enum class <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">thread::atomicx::NotifyType</link> : uint8_t<computeroutput>[strong]</computeroutput></computeroutput></para><informaltable frame="all">
<title>Enumerator</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<tbody>
<row><entry><indexterm><primary>one</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>one</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82"/>one</entry><entry></entry></row><row><entry><indexterm><primary>all</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>all</secondary></indexterm>
<anchor xml:id="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaa181a603769c1f98ad927e7367c7aa51"/>all</entry><entry></entry></row>    </tbody>
    </tgroup>
</informaltable>
</section>
</section>
<section>
<title>Constructor &amp; Destructor Documentation</title>
<anchor xml:id="_classthread_1_1atomicx_1ac460ddbc6a7201689a762fb8d3c35397"/><section>
    <title>~atomicx()</title>
<indexterm><primary>~atomicx</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>~atomicx</secondary></indexterm>
<para><computeroutput>thread::atomicx::~atomicx (void )<computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>virtual destructor of the atomicx </para>
</para>

<para>PUBLIC OBJECT METHOS </para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a06c82de06faf2019a9af23bc75886baa"/><section>
    <title>atomicx()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>atomicx</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>atomicx</secondary></indexterm>
<computeroutput>template&lt;typename T , size_t N&gt; </computeroutput><para><computeroutput>thread::atomicx::atomicx (T(&amp;) stack[N])<computeroutput>[inline]</computeroutput></computeroutput></para><para>

<para>Construct a new atomicx thread. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Stack memory page type </para>
</entry>
                            </row>
                            <row>
<entry>N</entry><entry>
<para>Stack memory page size </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ae227c8a72cddade05625f906b56f2cb7"/><section>
    <title>atomicx()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>atomicx</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>atomicx</secondary></indexterm>
<para><computeroutput>thread::atomicx::atomicx (size_t nStackSize = <computeroutput>0</computeroutput>
, int nStackIncreasePace = <computeroutput>1</computeroutput>
)</computeroutput></para><para>

<para>Construct a new atomicx object and set initial auto stack and increase pace. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>nStackSize</entry><entry>
<para>Initial Size of the stack </para>
</entry>
                            </row>
                            <row>
<entry>nStackIncreasePace</entry><entry>
<para>defalt=1, The increase pace on each resize </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
</section>
<section>
<title>Member Function Documentation</title>
<anchor xml:id="_classthread_1_1atomicx_1a0e188b4cdad5fb7f9fff7cd1e0f438aa"/><section>
    <title>begin()</title>
<indexterm><primary>begin</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>begin</secondary></indexterm>
<para><computeroutput><link linkend="_classthread_1_1atomicx_1_1aiterator">atomicx::aiterator</link> thread::atomicx::begin (void )</computeroutput></para><para>

<para>Get the beggining of the list. </para>
</para>

<para><formalpara><title>Returns</title>

<para>aiterator </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ae43c2d0de94878ce0602a3b40d4deeba"/><section>
    <title>BrokerHandler()</title>
<indexterm><primary>BrokerHandler</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>BrokerHandler</secondary></indexterm>
<para><computeroutput>virtual bool thread::atomicx::BrokerHandler (const char * pszKey, size_t nKeyLenght, <link linkend="_structthread_1_1atomicx_1_1_message">Message</link> &amp; message)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Default broker handler for a subscribed message. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszKey</entry><entry>
<para>The Topic C string </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>The Topic C string size in bytes </para>
</entry>
                            </row>
                            <row>
<entry>message</entry><entry>
<para>The atomicx::message payload received</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true signify it was correctly processed</para>
</formalpara>
<note><title>Note</title>

<para>Can be overloaded by the derived by the derived thread implementation and specialized, otherwise a empty function will be called instead </para>
</note>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a8a832099edb224496c7ba204695138c7"/><section>
    <title>end()</title>
<indexterm><primary>end</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>end</secondary></indexterm>
<para><computeroutput><link linkend="_classthread_1_1atomicx_1_1aiterator">atomicx::aiterator</link> thread::atomicx::end (void )</computeroutput></para><para>

<para>Get the end of the list. </para>
</para>

<para><formalpara><title>Returns</title>

<para>aiterator </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a641e79e24059fb3fcaf81ee54a2009be"/><section>
    <title>finish()</title>
<indexterm><primary>finish</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>finish</secondary></indexterm>
<para><computeroutput>virtual void thread::atomicx::finish ( )<computeroutput>[inline]</computeroutput>, <computeroutput>[virtual]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Called right after run returns, can be used to self-destroy the object and other maintenance actions. </para>
</para>

<para><note><title>Note</title>

<para>if not implemented a default &quot;empty&quot; call is used instead </para>
</note>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a0a73c90e27fec5dea704c430c36e0cee"/><section>
    <title>GetCurrent()</title>
<indexterm><primary>GetCurrent</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetCurrent</secondary></indexterm>
<para><computeroutput><link linkend="_classthread_1_1atomicx">atomicx</link> * thread::atomicx::GetCurrent ( )<computeroutput>[static]</computeroutput></computeroutput></para><para>

<para>Get the Current thread in execution. </para>
</para>

<para><formalpara><title>Returns</title>

<para>atomicx* thread </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ac357706436b933641d236447cdbd5462"/><section>
    <title>GetCurrentTick()</title>
<indexterm><primary>GetCurrentTick</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetCurrentTick</secondary></indexterm>
<para><computeroutput><link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> thread::atomicx::GetCurrentTick (void )</computeroutput></para><para>

<para>Get the Current Tick using the ported tick granularity function. </para>
</para>

<para><formalpara><title>Returns</title>

<para>atomicx_time based on the ported tick granularity </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a75865402817f74f5917c958c2cc631ed"/><section>
    <title>GetID()</title>
<indexterm><primary>GetID</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetID</secondary></indexterm>
<para><computeroutput>size_t thread::atomicx::GetID (void )</computeroutput></para><para>

<para>Get the current thread ID. </para>
</para>

<para><formalpara><title>Returns</title>

<para>size_t Thread ID number </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1af7c7ea1f95881fbc140c2a8f4cbf3c2e"/><section>
    <title>GetLastUserExecTime()</title>
<indexterm><primary>GetLastUserExecTime</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetLastUserExecTime</secondary></indexterm>
<para><computeroutput><link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> thread::atomicx::GetLastUserExecTime ( )</computeroutput></para><para>

<para>Get the Last Execution of User Code. </para>
</para>

<para><formalpara><title>Returns</title>

<para>atomicx_time </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a06fba915b6d19dd927f28a7b88fa566b"/><section>
    <title>GetName()</title>
<indexterm><primary>GetName</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetName</secondary></indexterm>
<para><computeroutput>const char * thread::atomicx::GetName (void )<computeroutput>[virtual]</computeroutput></computeroutput></para></section>
<anchor xml:id="_classthread_1_1atomicx_1a075d951e2432e1e06f04691e3b83b2d5"/><section>
    <title>GetNice()</title>
<indexterm><primary>GetNice</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetNice</secondary></indexterm>
<para><computeroutput><link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> thread::atomicx::GetNice (void )</computeroutput></para><para>

<para>Get the Nice the current thread. </para>
</para>

<para><formalpara><title>Returns</title>

<para>atomicx_time the number representing the nice and based on the ported tick granularity. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a238414e659cf1bd1ac7b79eae1de1d10"/><section>
    <title>GetReferenceLock()</title>
<indexterm><primary>GetReferenceLock</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetReferenceLock</secondary></indexterm>
<para><computeroutput>size_t thread::atomicx::GetReferenceLock (void )</computeroutput></para><para>

<para>Get the Reference Lock last used to lock the thread. </para>
</para>

<para><formalpara><title>Returns</title>

<para>size_t the lock_id (used my wait) </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1aee0a056b991664861eade9caf6adbd32"/><section>
    <title>GetStackIncreasePace()</title>
<indexterm><primary>GetStackIncreasePace</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetStackIncreasePace</secondary></indexterm>
<para><computeroutput>size_t thread::atomicx::GetStackIncreasePace (void )</computeroutput></para><para>

<para>Get the Stack Increase Pace value. </para>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ad58b1b08bf0c0a3fe62affac1bffe845"/><section>
    <title>GetStackSize()</title>
<indexterm><primary>GetStackSize</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetStackSize</secondary></indexterm>
<para><computeroutput>size_t thread::atomicx::GetStackSize (void )</computeroutput></para><para>

<para>Get the Max Stack Size for the thread. </para>
</para>

<para><formalpara><title>Returns</title>

<para>size_t size in bytes </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a59ff0db3d410d11672a4376432ec8188"/><section>
    <title>GetStatus()</title>
<indexterm><primary>GetStatus</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetStatus</secondary></indexterm>
<para><computeroutput>int thread::atomicx::GetStatus (void )</computeroutput></para><para>

<para>Get the current thread status. </para>
</para>

<para><formalpara><title>Returns</title>

<para>int use <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007ed">atomicx::aTypes</link> </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ab9b7e5c959deefbe1dfccab55233a0c7"/><section>
    <title>GetSubStatus()</title>
<indexterm><primary>GetSubStatus</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetSubStatus</secondary></indexterm>
<para><computeroutput>int thread::atomicx::GetSubStatus (void )</computeroutput></para><para>

<para>Get the current thread sub status. </para>
</para>

<para><formalpara><title>Returns</title>

<para>int use <link linkend="_classthread_1_1atomicx_1a82633f5364d51f3b5a8dfed1e93007ed">atomicx::aTypes</link> </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a080c7d232dece44e29b3858fd4f2ac8c"/><section>
    <title>GetTagLock()</title>
<indexterm><primary>GetTagLock</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetTagLock</secondary></indexterm>
<para><computeroutput>size_t thread::atomicx::GetTagLock (void )</computeroutput></para><para>

<para>Get the last tag message posted. </para>
</para>

<para><formalpara><title>Returns</title>

<para>size_t atomicx::message::tag value </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a96d17265ebe39e32586b4e117c15ae68"/><section>
    <title>GetTargetTime()</title>
<indexterm><primary>GetTargetTime</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetTargetTime</secondary></indexterm>
<para><computeroutput><link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> thread::atomicx::GetTargetTime (void )</computeroutput></para><para>

<para>Get next moment in ported tick granularity the thread will be due to return. </para>
</para>

<para><formalpara><title>Returns</title>

<para>atomicx_time based on the ported tick granularity </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ab27f5a456d8983f5c17102bc0aaa0da0"/><section>
    <title>GetTopicID()</title>
<indexterm><primary>GetTopicID</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetTopicID</secondary></indexterm>
<para><computeroutput>uint32_t thread::atomicx::GetTopicID (const char * pszTopic, size_t nKeyLenght)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>calculate the Topic ID for a given topic text </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszTopic</entry><entry>
<para>Topic Text in C string </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>Size, in bytes + zero terminated char</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>uint32_t The calculated topic ID </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a5bdde2eddb025706719d11632b4450b7"/><section>
    <title>GetUsedStackSize()</title>
<indexterm><primary>GetUsedStackSize</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>GetUsedStackSize</secondary></indexterm>
<para><computeroutput>size_t thread::atomicx::GetUsedStackSize (void )</computeroutput></para><para>

<para>Get the Used Stack Size for the thread since the last context change cycle. </para>
</para>

<para><formalpara><title>Returns</title>

<para>size_t size in bytes </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ab6b7c287310a686e589c57947084124b"/><section>
    <title>HasSubscriptions()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>HasSubscriptions</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>HasSubscriptions</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::HasSubscriptions (const char * pszTopic, size_t nKeyLenght)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Check if there is subscryption for a specific Topic String. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszTopic</entry><entry>
<para>The Topic string in C string </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>The Topic C string length in bytes</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if any substriction is found, otherwise false </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ad335842d925985e2ea56639c5eda0f22"/><section>
    <title>HasSubscriptions()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>HasSubscriptions</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>HasSubscriptions</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::HasSubscriptions (uint32_t nKeyID)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Check if there is subscryption for a specific Topic ID. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>nKeyID</entry><entry>
<para>The Topic ID uint32_t</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if any substriction is found, otherwise false </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1af86a54fe9571c2fbab03c9f62f453ad5"/><section>
    <title>HasWaitings()</title>
<indexterm><primary>HasWaitings</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>HasWaitings</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>size_t thread::atomicx::HasWaitings (T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Report how much waiting threads for a given reference pointer and tag value are there. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer used a a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The size_t tag that will give meaning to the notification, if nTag == 0 mean all bTag for the refVar </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true</para>
</formalpara>
<note><title>Note</title>

<para>This is a powerful tool since it create layers of waiting within the same reference pointer </para>
</note>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ae80cbf9f8fc2617eaa168d1281225715"/><section>
    <title>IsDynamicNiceOn()</title>
<indexterm><primary>IsDynamicNiceOn</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>IsDynamicNiceOn</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::IsDynamicNiceOn ( )</computeroutput></para><para>

<para>Get Dynamic Nice status. </para>
</para>

<para><formalpara><title>Returns</title>

<para>true if dynamic nice is on otherwise off </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ae8d4a2b0d8f59ea33a59236d69034cc7"/><section>
    <title>IsStackSelfManaged()</title>
<indexterm><primary>IsStackSelfManaged</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>IsStackSelfManaged</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::IsStackSelfManaged (void )</computeroutput></para><para>

<para>Return if the current thread&apos;s stack memory is automatic. </para>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a2407946fa015153b0a813d9ea7d15019"/><section>
    <title>IsSubscribed()</title>
<indexterm><primary>IsSubscribed</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>IsSubscribed</secondary></indexterm>
<para><computeroutput>virtual bool thread::atomicx::IsSubscribed (const char * pszKey, size_t nKeyLenght)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput>, <computeroutput>[virtual]</computeroutput></computeroutput></para><para>

<para>Specialize and gives power to decide if a topic is subscrybed on not. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszKey</entry><entry>
<para>The Topic C String </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>The Topic C String size in bytes</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if the given topic was subscribed, otherwise false. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ad4512ab7de89d7cfd6b5d60c2d986b3e"/><section>
    <title>IsWaiting()</title>
<indexterm><primary>IsWaiting</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>IsWaiting</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>bool thread::atomicx::IsWaiting (T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, size_t hasAtleast = <computeroutput>1</computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Check if there are waiting threads for a given reference pointer and tag value. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer used a a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The size_t tag that will give meaning to the notification, if nTag == 0 mean all bTag for the refVar </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true</para>
</formalpara>
<note><title>Note</title>

<para>This is a powerful tool since it create layers of waiting within the same reference pointer </para>
</note>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1af919d7337b1a6cc5912cd1c7c4fe5ea8"/><section>
    <title>LookForWaitings()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>LookForWaitings</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>LookForWaitings</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>bool thread::atomicx::LookForWaitings (T &amp; refVar, size_t nTag, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitFor)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Sync with thread call for a wait (refVar,nTag) </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The notification meaning, if nTag == 0 means wait all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>waitFor</entry><entry>
<para>default=0, if 0 wait indefinitely, otherwise wait for custom tick granularity times</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true There is thread waiting for the given refVar/nTag </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a3a7a1c5a1e645c09c0ff0a6c355404c5"/><section>
    <title>LookForWaitings()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>LookForWaitings</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>LookForWaitings</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>bool thread::atomicx::LookForWaitings (T &amp; refVar, size_t nTag, size_t hasAtleast, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitFor)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Sync with thread call for a wait (refVar,nTag) </para>
</para>

<para><informaltable frame='bottom'><tgroup cols='1'><colspec align='center'/><tbody><row><entry align='center'>
</entry></row></tbody></tgroup></informaltable>
 </para>
<section xml:id="_classthread_1_1atomicx_1autotoc_md13">
<title>SMART WAIT/NOTIFY  IMPLEMENTATION</title>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The notification meaning, if nTag == 0 means wait all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>waitFor</entry><entry>
<para>default=0, if 0 wait indefinitely, otherwise wait for custom tick granularity times </para>
</entry>
                            </row>
                            <row>
<entry>hasAtleast</entry><entry>
<para>define how minimal Wait calls to report true</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true There is thread waiting for the given refVar/nTag </para>
</formalpara>
</para>
</section>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a401db852c22e1982ae5c184ec93423c0"/><section>
    <title>Notify()<computeroutput>[1/3]</computeroutput></title>
<indexterm><primary>Notify</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>Notify</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>size_t thread::atomicx::Notify (size_t &amp;&amp; nMessage, T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll = <computeroutput><link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link></computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para></section>
<anchor xml:id="_classthread_1_1atomicx_1a8b3845a6f977e4fc9644e996d4102d75"/><section>
    <title>Notify()<computeroutput>[2/3]</computeroutput></title>
<indexterm><primary>Notify</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>Notify</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>size_t thread::atomicx::Notify (size_t &amp; nMessage, T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll = <computeroutput><link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link></computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Notify all Waits from a specific reference pointer along with a message and trigger context change if at least one wait thread got notified. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>nMessage</entry><entry>
<para>The size_t message to be sent </para>
</entry>
                            </row>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer used a a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>notifyAll</entry><entry>
<para>default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified. </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one got notified, otherwise false. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ad1d6b634c9c90c1c15acc391f2b97671"/><section>
    <title>Notify()<computeroutput>[3/3]</computeroutput></title>
<indexterm><primary>Notify</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>Notify</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>size_t thread::atomicx::Notify (T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll = <computeroutput><link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link></computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Notify all Waits from a specific reference pointer and trigger context change if at least one wait thread got notified. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer used a a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>notifyAll</entry><entry>
<para>default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified. </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one got notified, otherwise false. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a686358de14f2be34e688ee22dd5bc5b8"/><section>
    <title>Publish()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>Publish</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>Publish</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::Publish (const char * pszKey, size_t nKeyLenght)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Publish a notification for a specific topic string and trigger a context change if any delivered. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszKey</entry><entry>
<para>The Topic string </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>The size of the topic string in bytes</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one thread has received a message </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1afc67058a34cd39f3f853a7f9a2ae84fd"/><section>
    <title>Publish()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>Publish</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>Publish</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::Publish (const char * pszKey, size_t nKeyLenght, const <link linkend="_structthread_1_1atomicx_1_1_message">Message</link> message)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Publish a message for a specific topic string and trigger a context change if any delivered. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszKey</entry><entry>
<para>The Topic string </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>The size of the topic string in bytes </para>
</entry>
                            </row>
                            <row>
<entry>message</entry><entry>
<para>the atomicx::message structure with message and tag</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one thread has received a message </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a8917ef300f396b3d8bc9fdd8aacccf14"/><section>
    <title>run()</title>
<indexterm><primary>run</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>run</secondary></indexterm>
<para><computeroutput>virtual void thread::atomicx::run (void )<computeroutput>[pure virtual]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>The pure virtual function that runs the thread loop. </para>
</para>

<para><note><title>Note</title>

<para>REQUIRED implementation and once it returns it will execute finish method </para>
</note>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a1cb98240204ba7c5981ad9ffba095253"/><section>
    <title>SafeNotify()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>SafeNotify</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SafeNotify</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>size_t thread::atomicx::SafeNotify (size_t &amp; nMessage, T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll = <computeroutput><link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link></computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Safely notify all Waits from a specific reference pointer along with a message without triggering context change. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>nMessage</entry><entry>
<para>The size_t message to be sent </para>
</entry>
                            </row>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer used a a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>notifyAll</entry><entry>
<para>default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified. </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one got notified, otherwise false. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a3658882cb26cc60166bf7b29a7024d14"/><section>
    <title>SafeNotify()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>SafeNotify</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SafeNotify</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>size_t thread::atomicx::SafeNotify (T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll = <computeroutput><link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link></computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Safely notify all Waits from a specific reference pointer without triggering context change. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer used a a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>notifyAll</entry><entry>
<para>default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified. </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one got notified, otherwise false. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a4877838c0c1e38a7941f7ca86926ada9"/><section>
    <title>SafePublish()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>SafePublish</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SafePublish</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::SafePublish (const char * pszKey, size_t nKeyLenght)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Safely Publish a notification for a specific topic string DO NOT trigger a context change if any delivered. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszKey</entry><entry>
<para>The Topic string </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>The size of the topic string in bytes</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one thread has received a message</para>
</formalpara>
<note><title>Note</title>

<para>Ideal for been used with interrupt request </para>
</note>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a5b238f8831ae0cb3a53c685123e5a5d8"/><section>
    <title>SafePublish()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>SafePublish</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SafePublish</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::SafePublish (const char * pszKey, size_t nKeyLenght, const <link linkend="_structthread_1_1atomicx_1_1_message">Message</link> message)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Safely Publish a message for a specific topic string DO NOT trigger a context change if any delivered. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszKey</entry><entry>
<para>The Topic string </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>The size of the topic string in bytes </para>
</entry>
                            </row>
                            <row>
<entry>message</entry><entry>
<para>the atomicx::message structure with message and tag</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one thread has received a message</para>
</formalpara>
<note><title>Note</title>

<para>Ideal for been used with interrupt request </para>
</note>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1aee21cbd30a48efbf3a55817ad9bfe3e3"/><section>
    <title>SetDynamicNice()</title>
<indexterm><primary>SetDynamicNice</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SetDynamicNice</secondary></indexterm>
<para><computeroutput>void thread::atomicx::SetDynamicNice (bool status)</computeroutput></para><para>

<para>Set the Dynamic Nice on and off. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>status</entry><entry>
<para>True for on otherwsize off </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a6663c1d4f9483ee2b00ff01426efb6c7"/><section>
    <title>SetNice()</title>
<indexterm><primary>SetNice</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SetNice</secondary></indexterm>
<para><computeroutput>void thread::atomicx::SetNice (<link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> nice)</computeroutput></para><para>

<para>Set the Nice of the thread. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>nice</entry><entry>
<para>in atomicx_time reference based on the ported tick granularity </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1acfdf080727d53cbaf31cd6b8c6595e5b"/><section>
    <title>SetStackIncreasePace()</title>
<indexterm><primary>SetStackIncreasePace</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SetStackIncreasePace</secondary></indexterm>
<para><computeroutput>void thread::atomicx::SetStackIncreasePace (size_t nIncreasePace)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Set the Stack Increase Pace object. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>nIncreasePace</entry><entry>
<para>The new stack increase pace value </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a8f358048df310da5b3f0b669605fc197"/><section>
    <title>StackOverflowHandler()</title>
<indexterm><primary>StackOverflowHandler</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>StackOverflowHandler</secondary></indexterm>
<para><computeroutput>virtual void thread::atomicx::StackOverflowHandler (void )<computeroutput>[pure virtual]</computeroutput>, <computeroutput>[noexcept]</computeroutput></computeroutput></para><para>

<para>Handles the StackOverflow of the current thread. </para>
</para>

<para><note><title>Note</title>

<para>REQUIRED </para>
</note>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a64de6117b863b3d2edd217798d9c27f4"/><section>
    <title>Start()</title>
<indexterm><primary>Start</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>Start</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::Start (void )<computeroutput>[static]</computeroutput></computeroutput></para><para>

<para>Once it is call the process blocks execution and start all threads. </para>
</para>

<para><formalpara><title>Returns</title>

<para>false if it was destried by dead lock (all threads locked) </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a7e4e0bf42bafa19be930b43b72d244f7"/><section>
    <title>SyncNotify()<computeroutput>[1/3]</computeroutput></title>
<indexterm><primary>SyncNotify</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SyncNotify</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>size_t thread::atomicx::SyncNotify (size_t &amp;&amp; nMessage, T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitForWaitings = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll = <computeroutput><link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link></computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para></section>
<anchor xml:id="_classthread_1_1atomicx_1a91a943d6b7dbce240fb8bc611edead6b"/><section>
    <title>SyncNotify()<computeroutput>[2/3]</computeroutput></title>
<indexterm><primary>SyncNotify</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SyncNotify</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>size_t thread::atomicx::SyncNotify (size_t &amp; nMessage, T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitForWaitings = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll = <computeroutput><link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link></computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>SYNC Waits for at least one Wait call for a given reference pointer along with a message and trigger context change. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>nMessage</entry><entry>
<para>The size_t message to be sent </para>
</entry>
                            </row>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer used a a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>waitForWaitings</entry><entry>
<para>default=0 (waiting for Waiting calls) othersize wait for Wait commands compatible with the paramenters (Sync call). </para>
</entry>
                            </row>
                            <row>
<entry>notifyAll</entry><entry>
<para>default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified. </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one got notified, otherwise false. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1aad548d78d129a70a9e68862e06d4db9d"/><section>
    <title>SyncNotify()<computeroutput>[3/3]</computeroutput></title>
<indexterm><primary>SyncNotify</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>SyncNotify</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>size_t thread::atomicx::SyncNotify (T &amp; refVar, size_t nTag, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitForWaitings = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275ab">NotifyType</link> notifyAll = <computeroutput><link linkend="_classthread_1_1atomicx_1a95cb3ab240d8e0c05e70f6d7a55275abaf97c5d29941bfb1b2fdab0874906ab82">NotifyType::one</link></computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>SYNC Waits for at least one Wait call for a given reference pointer and trigger context change. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>refVar</entry><entry>
<para>The reference pointer used a a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>waitForWaitings</entry><entry>
<para>default=0 (waiting for Waiting calls) othersize wait for Wait commands compatible with the paramenters (Sync call). </para>
</entry>
                            </row>
                            <row>
<entry>notifyAll</entry><entry>
<para>default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified. </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if at least one got notified, otherwise false. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a51434a435b3470ee885272a18e7838bb"/><section>
    <title>Wait()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>Wait</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>Wait</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>bool thread::atomicx::Wait (size_t &amp; nMessage, T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitFor = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Blocks/Waits a notification along with a message and tag from a specific reference pointer. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>nMessage</entry><entry>
<para>the size_t message to be received </para>
</entry>
                            </row>
                            <row>
<entry>refVar</entry><entry>
<para>the reference pointer used as a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>the size_t tag that will give meaning to the the message, if nTag == 0 means wait all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>waitFor</entry><entry>
<para>default==0 (undefinitly), How log to wait for a notification based on atomicx_time </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if it was successfully received. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1aae81685ea59341f64a4b3d8cc5886563"/><section>
    <title>Wait()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>Wait</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>Wait</secondary></indexterm>
<computeroutput>template&lt;typename T &gt; </computeroutput><para><computeroutput>bool thread::atomicx::Wait (T &amp; refVar, size_t nTag = <computeroutput>0</computeroutput>
, <link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> waitFor = <computeroutput>0</computeroutput>
, <link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67f">aSubTypes</link> asubType = <computeroutput><link linkend="_classthread_1_1atomicx_1ad539e1e9bbab631727153dea853aa67fa49256b9819abacbb8e6e031a03abe81b">aSubTypes::wait</link></computeroutput>
)<computeroutput>[inline]</computeroutput>, <computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Blocks/Waits a notification along with a tag from a specific reference pointer. </para>
</para>

<para>
                <formalpara>
                    <title>
Template Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>T</entry><entry>
<para>Type of the reference pointer </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>refVar</entry><entry>
<para>the reference pointer used as a notifier </para>
</entry>
                            </row>
                            <row>
<entry>nTag</entry><entry>
<para>the size_t tag that will give meaning to the the message, if nTag == 0 means wait all refVar regardless </para>
</entry>
                            </row>
                            <row>
<entry>waitFor</entry><entry>
<para>default==0 (undefinitly), How log to wait for a notification based on atomicx_time </para>
</entry>
                            </row>
                            <row>
<entry>asubType</entry><entry>
<para>Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if it was successfully received. </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a1cfdab652a4a90fa8c760d9ee3a802fb"/><section>
    <title>WaitBrokerMessage()<computeroutput>[1/2]</computeroutput></title>
<indexterm><primary>WaitBrokerMessage</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>WaitBrokerMessage</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::WaitBrokerMessage (const char * pszKey, size_t nKeyLenght)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Block and wait for a notification from a specific topic string. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszKey</entry><entry>
<para>The Topic string </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>The size of the topic string in bytes</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if it was successfully received, otherwise false </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a407be004173a7db41834eb58fb8f4436"/><section>
    <title>WaitBrokerMessage()<computeroutput>[2/2]</computeroutput></title>
<indexterm><primary>WaitBrokerMessage</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>WaitBrokerMessage</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::WaitBrokerMessage (const char * pszKey, size_t nKeyLenght, <link linkend="_structthread_1_1atomicx_1_1_message">Message</link> &amp; message)<computeroutput>[protected]</computeroutput></computeroutput></para><para>

<para>Block and wait for message from a specific topic string. </para>
</para>

<para><informaltable frame='bottom'><tgroup cols='1'><colspec align='center'/><tbody><row><entry align='center'>
</entry></row></tbody></tgroup></informaltable>
 </para>
<section xml:id="_classthread_1_1atomicx_1autotoc_md15">
<title>SMART BROKER IMPLEMENTATION</title>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>pszKey</entry><entry>
<para>The Topic string </para>
</entry>
                            </row>
                            <row>
<entry>nKeyLenght</entry><entry>
<para>The size of the topic string in bytes </para>
</entry>
                            </row>
                            <row>
<entry>message</entry><entry>
<para>the atomicx::message structure with message and tag</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if it was successfully received, otherwise false </para>
</formalpara>
</para>
</section>
</section>
<anchor xml:id="_classthread_1_1atomicx_1ab3dd1245396fc470b7b2c6a31a4455ca"/><section>
    <title>Yield()</title>
<indexterm><primary>Yield</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>Yield</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::Yield (<link linkend="_atomicx_8hpp_1a920b9cf8bd44e31bfb1bfdf4cb1c9080">atomicx_time</link> nSleep = <computeroutput><link linkend="_atomicx_8hpp_1a5f79904e0c0abe4f6120ed97f66b3802">ATOMICX_TIME_MAX</link></computeroutput>
)</computeroutput></para><para>

<para>Foce the context change explicitly. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>nSleep</entry><entry>
<para>default is ATOMICX_TIME_MAX, otherwise it will override the nice and sleep for n custom tick granularity</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>true if the context came back correctly, otherwise false </para>
</formalpara>
</para>
</section>
<anchor xml:id="_classthread_1_1atomicx_1a8b38e8d84d71903a9162bcc541235614"/><section>
    <title>YieldNow()</title>
<indexterm><primary>YieldNow</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>YieldNow</secondary></indexterm>
<para><computeroutput>void thread::atomicx::YieldNow (void )</computeroutput></para><para>

<para>Trigger a high priority NOW, caution it will always execute before normal yield. </para>
</para>
</section>
</section>
<section>
<title>Field Documentation</title>
<anchor xml:id="_classthread_1_1atomicx_1abb1519b6cc2f9dbe3521f3cffd011f15"/><section>
    <title>autoStack</title>
<indexterm><primary>autoStack</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>autoStack</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::autoStack</computeroutput></para></section>
<anchor xml:id="_classthread_1_1atomicx_1a736d1417c7f474e02b2684eebfb96b78"/><section>
    <title>dynamicNice</title>
<indexterm><primary>dynamicNice</primary><secondary>thread::atomicx</secondary></indexterm>
<indexterm><primary>thread::atomicx</primary><secondary>dynamicNice</secondary></indexterm>
<para><computeroutput>bool thread::atomicx::dynamicNice</computeroutput></para></section>
<para>
The documentation for this class was generated from the following files:</para>
atomicx/<link linkend="_atomicx_8hpp">atomicx.hpp</link>atomicx/<link linkend="_atomicx_8cpp">atomicx.cpp</link></section>
</section>
