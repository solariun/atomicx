.TH "thread::atomicx" 3 "Sun Jan 30 2022" "AtomicX" \" -*- nroff -*-
.ad l
.nh
.SH NAME
thread::atomicx
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <atomicx\&.hpp>\fP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBaiterator\fP"
.br
.ti -1c
.RI "struct \fBMessage\fP"
.br
.ti -1c
.RI "class \fBmutex\fP"
.br
.ti -1c
.RI "class \fBqueue\fP"
.br
.ti -1c
.RI "class \fBsemaphore\fP"
.br
.ti -1c
.RI "class \fBsmart_ptr\fP"
.br
.ti -1c
.RI "class \fBsmartMutex\fP"
.br
.RI "RII compliance lock/shared lock to auto unlock on destruction\&. "
.ti -1c
.RI "class \fBsmartSemaphore\fP"
.br
.ti -1c
.RI "class \fBTimeout\fP"
.br
.RI "\fBTimeout\fP Check object\&. "
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum class \fBaTypes\fP : uint8_t { \fBstart\fP =1, \fBrunning\fP =5, \fBnow\fP =6, \fBstop\fP =10, \fBlock\fP =50, \fBwait\fP =55, \fBsubscription\fP =60, \fBsleep\fP =100, \fBstackOverflow\fP =255 }"
.br
.ti -1c
.RI "enum class \fBaSubTypes\fP : uint8_t { \fBerror\fP =10, \fBok\fP, \fBlook\fP, \fBwait\fP, \fBtimeout\fP }"
.br
.ti -1c
.RI "enum class \fBNotifyType\fP : uint8_t { \fBone\fP = 0, \fBall\fP = 1 }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBaiterator\fP \fBbegin\fP (void)"
.br
.RI "Get the beggining of the list\&. "
.ti -1c
.RI "\fBaiterator\fP \fBend\fP (void)"
.br
.RI "Get the end of the list\&. "
.ti -1c
.RI "virtual \fB~atomicx\fP (void)"
.br
.RI "virtual destructor of the atomicx "
.ti -1c
.RI "size_t \fBGetID\fP (void)"
.br
.RI "Get the current thread ID\&. "
.ti -1c
.RI "size_t \fBGetStackSize\fP (void)"
.br
.RI "Get the Max Stack Size for the thread\&. "
.ti -1c
.RI "\fBatomicx_time\fP \fBGetNice\fP (void)"
.br
.RI "Get the Nice the current thread\&. "
.ti -1c
.RI "size_t \fBGetUsedStackSize\fP (void)"
.br
.RI "Get the Used Stack Size for the thread since the last context change cycle\&. "
.ti -1c
.RI "\fBatomicx_time\fP \fBGetCurrentTick\fP (void)"
.br
.RI "Get the Current Tick using the ported tick granularity function\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBatomicx\fP * \fBGetCurrent\fP ()"
.br
.RI "Get the Current thread in execution\&. "
.ti -1c
.RI "static bool \fBStart\fP (void)"
.br
.RI "Once it is call the process blocks execution and start all threads\&. "
.in -1c
.SS "If GetName was not overloaded by the derived thread implementation"
Get the Name object
.PP
\fBReturns\fP
.RS 4
const char* name in plain c string
.RE
.PP
a standard name will be returned\&. 
.in +1c
.ti -1c
.RI "virtual const char * \fBGetName\fP (void)"
.br
.ti -1c
.RI "\fBatomicx_time\fP \fBGetTargetTime\fP (void)"
.br
.RI "Get next moment in ported tick granularity the thread will be due to return\&. "
.ti -1c
.RI "int \fBGetStatus\fP (void)"
.br
.RI "Get the current thread status\&. "
.ti -1c
.RI "int \fBGetSubStatus\fP (void)"
.br
.RI "Get the current thread sub status\&. "
.ti -1c
.RI "size_t \fBGetReferenceLock\fP (void)"
.br
.RI "Get the Reference Lock last used to lock the thread\&. "
.ti -1c
.RI "size_t \fBGetTagLock\fP (void)"
.br
.RI "Get the last tag message posted\&. "
.ti -1c
.RI "void \fBSetNice\fP (\fBatomicx_time\fP nice)"
.br
.RI "Set the Nice of the thread\&. "
.ti -1c
.RI "template<typename T , size_t N> \fBatomicx\fP (T(&stack)[N])"
.br
.RI "Construct a new atomicx thread\&. "
.ti -1c
.RI "\fBatomicx\fP (size_t nStackSize=0, int nStackIncreasePace=1)"
.br
.RI "Construct a new atomicx object and set initial auto stack and increase pace\&. "
.ti -1c
.RI "virtual void \fBrun\fP (void) noexcept=0"
.br
.RI "The pure virtual function that runs the thread loop\&. "
.ti -1c
.RI "virtual void \fBStackOverflowHandler\fP (void) noexcept=0"
.br
.RI "Handles the StackOverflow of the current thread\&. "
.ti -1c
.RI "virtual void \fBfinish\fP () noexcept"
.br
.RI "Called right after run returns, can be used to self-destroy the object and other maintenance actions\&. "
.ti -1c
.RI "bool \fBIsStackSelfManaged\fP (void)"
.br
.RI "Return if the current thread's stack memory is automatic\&. "
.ti -1c
.RI "bool \fBYield\fP (\fBatomicx_time\fP nSleep=\fBATOMICX_TIME_MAX\fP)"
.br
.RI "Foce the context change explicitly\&. "
.ti -1c
.RI "\fBatomicx_time\fP \fBGetLastUserExecTime\fP ()"
.br
.RI "Get the Last Execution of User Code\&. "
.ti -1c
.RI "size_t \fBGetStackIncreasePace\fP (void)"
.br
.RI "Get the Stack Increase Pace value\&. "
.ti -1c
.RI "void \fBYieldNow\fP (void)"
.br
.RI "Trigger a high priority NOW, caution it will always execute before normal yield\&. "
.ti -1c
.RI "void \fBSetDynamicNice\fP (bool status)"
.br
.RI "Set the Dynamic Nice on and off\&. "
.ti -1c
.RI "bool \fBIsDynamicNiceOn\fP ()"
.br
.RI "Get Dynamic Nice status\&. "
.ti -1c
.RI "uint32_t \fBGetTopicID\fP (const char *pszTopic, size_t nKeyLenght)"
.br
.RI "calculate the Topic ID for a given topic text "
.ti -1c
.RI "template<typename T > bool \fBLookForWaitings\fP (T &refVar, size_t nTag, size_t hasAtleast, \fBatomicx_time\fP waitFor)"
.br
.RI "Sync with thread call for a wait (refVar,nTag) "
.ti -1c
.RI "template<typename T > bool \fBLookForWaitings\fP (T &refVar, size_t nTag, \fBatomicx_time\fP waitFor)"
.br
.RI "Sync with thread call for a wait (refVar,nTag) "
.ti -1c
.RI "template<typename T > bool \fBIsWaiting\fP (T &refVar, size_t nTag=0, size_t hasAtleast=1, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "Check if there are waiting threads for a given reference pointer and tag value\&. "
.ti -1c
.RI "template<typename T > size_t \fBHasWaitings\fP (T &refVar, size_t nTag=0, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "Report how much waiting threads for a given reference pointer and tag value are there\&. "
.ti -1c
.RI "template<typename T > bool \fBWait\fP (size_t &nMessage, T &refVar, size_t nTag=0, \fBatomicx_time\fP waitFor=0, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "Blocks/Waits a notification along with a message and tag from a specific reference pointer\&. "
.ti -1c
.RI "template<typename T > bool \fBWait\fP (T &refVar, size_t nTag=0, \fBatomicx_time\fP waitFor=0, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "Blocks/Waits a notification along with a tag from a specific reference pointer\&. "
.ti -1c
.RI "template<typename T > size_t \fBSafeNotify\fP (size_t &nMessage, T &refVar, size_t nTag=0, \fBNotifyType\fP notifyAll=\fBNotifyType::one\fP, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "Safely notify all Waits from a specific reference pointer along with a message without triggering context change\&. "
.ti -1c
.RI "template<typename T > size_t \fBNotify\fP (size_t &nMessage, T &refVar, size_t nTag=0, \fBNotifyType\fP notifyAll=\fBNotifyType::one\fP, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "Notify all Waits from a specific reference pointer along with a message and trigger context change if at least one wait thread got notified\&. "
.ti -1c
.RI "template<typename T > size_t \fBNotify\fP (size_t &&nMessage, T &refVar, size_t nTag=0, \fBNotifyType\fP notifyAll=\fBNotifyType::one\fP, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.ti -1c
.RI "template<typename T > size_t \fBSyncNotify\fP (size_t &nMessage, T &refVar, size_t nTag=0, \fBatomicx_time\fP waitForWaitings=0, \fBNotifyType\fP notifyAll=\fBNotifyType::one\fP, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "SYNC Waits for at least one Wait call for a given reference pointer along with a message and trigger context change\&. "
.ti -1c
.RI "template<typename T > size_t \fBSyncNotify\fP (size_t &&nMessage, T &refVar, size_t nTag=0, \fBatomicx_time\fP waitForWaitings=0, \fBNotifyType\fP notifyAll=\fBNotifyType::one\fP, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.ti -1c
.RI "template<typename T > size_t \fBSafeNotify\fP (T &refVar, size_t nTag=0, \fBNotifyType\fP notifyAll=\fBNotifyType::one\fP, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "Safely notify all Waits from a specific reference pointer without triggering context change\&. "
.ti -1c
.RI "template<typename T > size_t \fBSyncNotify\fP (T &refVar, size_t nTag, \fBatomicx_time\fP waitForWaitings=0, \fBNotifyType\fP notifyAll=\fBNotifyType::one\fP, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "SYNC Waits for at least one Wait call for a given reference pointer and trigger context change\&. "
.ti -1c
.RI "template<typename T > size_t \fBNotify\fP (T &refVar, size_t nTag=0, \fBNotifyType\fP notifyAll=\fBNotifyType::one\fP, \fBaSubTypes\fP asubType=\fBaSubTypes::wait\fP)"
.br
.RI "Notify all Waits from a specific reference pointer and trigger context change if at least one wait thread got notified\&. "
.ti -1c
.RI "bool \fBWaitBrokerMessage\fP (const char *pszKey, size_t nKeyLenght, \fBMessage\fP &message)"
.br
.RI "Block and wait for message from a specific topic string\&. "
.ti -1c
.RI "bool \fBWaitBrokerMessage\fP (const char *pszKey, size_t nKeyLenght)"
.br
.RI "Block and wait for a notification from a specific topic string\&. "
.ti -1c
.RI "bool \fBPublish\fP (const char *pszKey, size_t nKeyLenght, const \fBMessage\fP message)"
.br
.RI "Publish a message for a specific topic string and trigger a context change if any delivered\&. "
.ti -1c
.RI "bool \fBSafePublish\fP (const char *pszKey, size_t nKeyLenght, const \fBMessage\fP message)"
.br
.RI "Safely Publish a message for a specific topic string DO NOT trigger a context change if any delivered\&. "
.ti -1c
.RI "bool \fBPublish\fP (const char *pszKey, size_t nKeyLenght)"
.br
.RI "Publish a notification for a specific topic string and trigger a context change if any delivered\&. "
.ti -1c
.RI "bool \fBSafePublish\fP (const char *pszKey, size_t nKeyLenght)"
.br
.RI "Safely Publish a notification for a specific topic string DO NOT trigger a context change if any delivered\&. "
.ti -1c
.RI "bool \fBHasSubscriptions\fP (const char *pszTopic, size_t nKeyLenght)"
.br
.RI "Check if there is subscryption for a specific Topic String\&. "
.ti -1c
.RI "bool \fBHasSubscriptions\fP (uint32_t nKeyID)"
.br
.RI "Check if there is subscryption for a specific Topic ID\&. "
.ti -1c
.RI "virtual bool \fBBrokerHandler\fP (const char *pszKey, size_t nKeyLenght, \fBMessage\fP &message)"
.br
.RI "Default broker handler for a subscribed message\&. "
.ti -1c
.RI "virtual bool \fBIsSubscribed\fP (const char *pszKey, size_t nKeyLenght)"
.br
.RI "Specialize and gives power to decide if a topic is subscrybed on not\&. "
.ti -1c
.RI "void \fBSetStackIncreasePace\fP (size_t nIncreasePace)"
.br
.RI "Set the Stack Increase Pace object\&. "
.in -1c
.SH "Member Enumeration Documentation"
.PP 
.SS "enum class \fBthread::atomicx::aSubTypes\fP : uint8_t\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIerror \fP\fP
.TP
\fB\fIok \fP\fP
.TP
\fB\fIlook \fP\fP
.TP
\fB\fIwait \fP\fP
.TP
\fB\fItimeout \fP\fP
.SS "enum class \fBthread::atomicx::aTypes\fP : uint8_t\fC [strong]\fP"

.PP
 
.SS "STATE MACHINE TYPES"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIstart \fP\fP
.TP
\fB\fIrunning \fP\fP
.TP
\fB\fInow \fP\fP
.TP
\fB\fIstop \fP\fP
.TP
\fB\fIlock \fP\fP
.TP
\fB\fIwait \fP\fP
.TP
\fB\fIsubscription \fP\fP
.TP
\fB\fIsleep \fP\fP
.TP
\fB\fIstackOverflow \fP\fP
.SS "enum class \fBthread::atomicx::NotifyType\fP : uint8_t\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIone \fP\fP
.TP
\fB\fIall \fP\fP
.SH "Constructor & Destructor Documentation"
.PP 
.SS "thread::atomicx::~atomicx (void)\fC [virtual]\fP"

.PP
virtual destructor of the atomicx PUBLIC OBJECT METHOS 
.SS "template<typename T , size_t N> thread::atomicx::atomicx (T(&) stack[N])\fC [inline]\fP"

.PP
Construct a new atomicx thread\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Stack memory page type 
.br
\fIN\fP Stack memory page size 
.RE
.PP

.SS "thread::atomicx::atomicx (size_t nStackSize = \fC0\fP, int nStackIncreasePace = \fC1\fP)"

.PP
Construct a new atomicx object and set initial auto stack and increase pace\&. 
.PP
\fBParameters\fP
.RS 4
\fInStackSize\fP Initial Size of the stack 
.br
\fInStackIncreasePace\fP defalt=1, The increase pace on each resize 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "\fBatomicx::aiterator\fP thread::atomicx::begin (void)"

.PP
Get the beggining of the list\&. 
.PP
\fBReturns\fP
.RS 4
aiterator 
.RE
.PP

.SS "virtual bool thread::atomicx::BrokerHandler (const char * pszKey, size_t nKeyLenght, \fBMessage\fP & message)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Default broker handler for a subscribed message\&. 
.PP
\fBParameters\fP
.RS 4
\fIpszKey\fP The Topic C string 
.br
\fInKeyLenght\fP The Topic C string size in bytes 
.br
\fImessage\fP The atomicx::message payload received
.RE
.PP
\fBReturns\fP
.RS 4
true signify it was correctly processed
.RE
.PP
\fBNote\fP
.RS 4
Can be overloaded by the derived by the derived thread implementation and specialized, otherwise a empty function will be called instead 
.RE
.PP

.SS "\fBatomicx::aiterator\fP thread::atomicx::end (void)"

.PP
Get the end of the list\&. 
.PP
\fBReturns\fP
.RS 4
aiterator 
.RE
.PP

.SS "virtual void thread::atomicx::finish ()\fC [inline]\fP, \fC [virtual]\fP, \fC [noexcept]\fP"

.PP
Called right after run returns, can be used to self-destroy the object and other maintenance actions\&. 
.PP
\fBNote\fP
.RS 4
if not implemented a default 'empty' call is used instead 
.RE
.PP

.SS "\fBatomicx\fP * thread::atomicx::GetCurrent ()\fC [static]\fP"

.PP
Get the Current thread in execution\&. 
.PP
\fBReturns\fP
.RS 4
atomicx* thread 
.RE
.PP

.SS "\fBatomicx_time\fP thread::atomicx::GetCurrentTick (void)"

.PP
Get the Current Tick using the ported tick granularity function\&. 
.PP
\fBReturns\fP
.RS 4
atomicx_time based on the ported tick granularity 
.RE
.PP

.SS "size_t thread::atomicx::GetID (void)"

.PP
Get the current thread ID\&. 
.PP
\fBReturns\fP
.RS 4
size_t Thread ID number 
.RE
.PP

.SS "\fBatomicx_time\fP thread::atomicx::GetLastUserExecTime ()"

.PP
Get the Last Execution of User Code\&. 
.PP
\fBReturns\fP
.RS 4
atomicx_time 
.RE
.PP

.SS "const char * thread::atomicx::GetName (void)\fC [virtual]\fP"

.SS "\fBatomicx_time\fP thread::atomicx::GetNice (void)"

.PP
Get the Nice the current thread\&. 
.PP
\fBReturns\fP
.RS 4
atomicx_time the number representing the nice and based on the ported tick granularity\&. 
.RE
.PP

.SS "size_t thread::atomicx::GetReferenceLock (void)"

.PP
Get the Reference Lock last used to lock the thread\&. 
.PP
\fBReturns\fP
.RS 4
size_t the lock_id (used my wait) 
.RE
.PP

.SS "size_t thread::atomicx::GetStackIncreasePace (void)"

.PP
Get the Stack Increase Pace value\&. 
.SS "size_t thread::atomicx::GetStackSize (void)"

.PP
Get the Max Stack Size for the thread\&. 
.PP
\fBReturns\fP
.RS 4
size_t size in bytes 
.RE
.PP

.SS "int thread::atomicx::GetStatus (void)"

.PP
Get the current thread status\&. 
.PP
\fBReturns\fP
.RS 4
int use \fBatomicx::aTypes\fP 
.RE
.PP

.SS "int thread::atomicx::GetSubStatus (void)"

.PP
Get the current thread sub status\&. 
.PP
\fBReturns\fP
.RS 4
int use \fBatomicx::aTypes\fP 
.RE
.PP

.SS "size_t thread::atomicx::GetTagLock (void)"

.PP
Get the last tag message posted\&. 
.PP
\fBReturns\fP
.RS 4
size_t atomicx::message::tag value 
.RE
.PP

.SS "\fBatomicx_time\fP thread::atomicx::GetTargetTime (void)"

.PP
Get next moment in ported tick granularity the thread will be due to return\&. 
.PP
\fBReturns\fP
.RS 4
atomicx_time based on the ported tick granularity 
.RE
.PP

.SS "uint32_t thread::atomicx::GetTopicID (const char * pszTopic, size_t nKeyLenght)\fC [protected]\fP"

.PP
calculate the Topic ID for a given topic text 
.PP
\fBParameters\fP
.RS 4
\fIpszTopic\fP Topic Text in C string 
.br
\fInKeyLenght\fP Size, in bytes + zero terminated char
.RE
.PP
\fBReturns\fP
.RS 4
uint32_t The calculated topic ID 
.RE
.PP

.SS "size_t thread::atomicx::GetUsedStackSize (void)"

.PP
Get the Used Stack Size for the thread since the last context change cycle\&. 
.PP
\fBReturns\fP
.RS 4
size_t size in bytes 
.RE
.PP

.SS "bool thread::atomicx::HasSubscriptions (const char * pszTopic, size_t nKeyLenght)\fC [protected]\fP"

.PP
Check if there is subscryption for a specific Topic String\&. 
.PP
\fBParameters\fP
.RS 4
\fIpszTopic\fP The Topic string in C string 
.br
\fInKeyLenght\fP The Topic C string length in bytes
.RE
.PP
\fBReturns\fP
.RS 4
true if any substriction is found, otherwise false 
.RE
.PP

.SS "bool thread::atomicx::HasSubscriptions (uint32_t nKeyID)\fC [protected]\fP"

.PP
Check if there is subscryption for a specific Topic ID\&. 
.PP
\fBParameters\fP
.RS 4
\fInKeyID\fP The Topic ID uint32_t
.RE
.PP
\fBReturns\fP
.RS 4
true if any substriction is found, otherwise false 
.RE
.PP

.SS "template<typename T > size_t thread::atomicx::HasWaitings (T & refVar, size_t nTag = \fC0\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Report how much waiting threads for a given reference pointer and tag value are there\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrefVar\fP The reference pointer used a a notifier 
.br
\fInTag\fP The size_t tag that will give meaning to the notification, if nTag == 0 mean all bTag for the refVar 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait
.RE
.PP
\fBReturns\fP
.RS 4
true
.RE
.PP
\fBNote\fP
.RS 4
This is a powerful tool since it create layers of waiting within the same reference pointer 
.RE
.PP

.SS "bool thread::atomicx::IsDynamicNiceOn ()"

.PP
Get Dynamic Nice status\&. 
.PP
\fBReturns\fP
.RS 4
true if dynamic nice is on otherwise off 
.RE
.PP

.SS "bool thread::atomicx::IsStackSelfManaged (void)"

.PP
Return if the current thread's stack memory is automatic\&. 
.SS "virtual bool thread::atomicx::IsSubscribed (const char * pszKey, size_t nKeyLenght)\fC [inline]\fP, \fC [protected]\fP, \fC [virtual]\fP"

.PP
Specialize and gives power to decide if a topic is subscrybed on not\&. 
.PP
\fBParameters\fP
.RS 4
\fIpszKey\fP The Topic C String 
.br
\fInKeyLenght\fP The Topic C String size in bytes
.RE
.PP
\fBReturns\fP
.RS 4
true if the given topic was subscribed, otherwise false\&. 
.RE
.PP

.SS "template<typename T > bool thread::atomicx::IsWaiting (T & refVar, size_t nTag = \fC0\fP, size_t hasAtleast = \fC1\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Check if there are waiting threads for a given reference pointer and tag value\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrefVar\fP The reference pointer used a a notifier 
.br
\fInTag\fP The size_t tag that will give meaning to the notification, if nTag == 0 mean all bTag for the refVar 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait
.RE
.PP
\fBReturns\fP
.RS 4
true
.RE
.PP
\fBNote\fP
.RS 4
This is a powerful tool since it create layers of waiting within the same reference pointer 
.RE
.PP

.SS "template<typename T > bool thread::atomicx::LookForWaitings (T & refVar, size_t nTag, \fBatomicx_time\fP waitFor)\fC [inline]\fP, \fC [protected]\fP"

.PP
Sync with thread call for a wait (refVar,nTag) 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrefVar\fP The reference pointer 
.br
\fInTag\fP The notification meaning, if nTag == 0 means wait all refVar regardless 
.br
\fIwaitFor\fP default=0, if 0 wait indefinitely, otherwise wait for custom tick granularity times
.RE
.PP
\fBReturns\fP
.RS 4
true There is thread waiting for the given refVar/nTag 
.RE
.PP

.SS "template<typename T > bool thread::atomicx::LookForWaitings (T & refVar, size_t nTag, size_t hasAtleast, \fBatomicx_time\fP waitFor)\fC [inline]\fP, \fC [protected]\fP"

.PP
Sync with thread call for a wait (refVar,nTag) 
.PP
 
.SS "SMART WAIT/NOTIFY  IMPLEMENTATION"
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrefVar\fP The reference pointer 
.br
\fInTag\fP The notification meaning, if nTag == 0 means wait all refVar regardless 
.br
\fIwaitFor\fP default=0, if 0 wait indefinitely, otherwise wait for custom tick granularity times 
.br
\fIhasAtleast\fP define how minimal Wait calls to report true
.RE
.PP
\fBReturns\fP
.RS 4
true There is thread waiting for the given refVar/nTag 
.RE
.PP

.SS "template<typename T > size_t thread::atomicx::Notify (size_t && nMessage, T & refVar, size_t nTag = \fC0\fP, \fBNotifyType\fP notifyAll = \fC\fBNotifyType::one\fP\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.SS "template<typename T > size_t thread::atomicx::Notify (size_t & nMessage, T & refVar, size_t nTag = \fC0\fP, \fBNotifyType\fP notifyAll = \fC\fBNotifyType::one\fP\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Notify all Waits from a specific reference pointer along with a message and trigger context change if at least one wait thread got notified\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fInMessage\fP The size_t message to be sent 
.br
\fIrefVar\fP The reference pointer used a a notifier 
.br
\fInTag\fP The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless 
.br
\fInotifyAll\fP default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified\&. 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one got notified, otherwise false\&. 
.RE
.PP

.SS "template<typename T > size_t thread::atomicx::Notify (T & refVar, size_t nTag = \fC0\fP, \fBNotifyType\fP notifyAll = \fC\fBNotifyType::one\fP\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Notify all Waits from a specific reference pointer and trigger context change if at least one wait thread got notified\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrefVar\fP The reference pointer used a a notifier 
.br
\fInTag\fP The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless 
.br
\fInotifyAll\fP default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified\&. 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one got notified, otherwise false\&. 
.RE
.PP

.SS "bool thread::atomicx::Publish (const char * pszKey, size_t nKeyLenght)\fC [protected]\fP"

.PP
Publish a notification for a specific topic string and trigger a context change if any delivered\&. 
.PP
\fBParameters\fP
.RS 4
\fIpszKey\fP The Topic string 
.br
\fInKeyLenght\fP The size of the topic string in bytes
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one thread has received a message 
.RE
.PP

.SS "bool thread::atomicx::Publish (const char * pszKey, size_t nKeyLenght, const \fBMessage\fP message)\fC [protected]\fP"

.PP
Publish a message for a specific topic string and trigger a context change if any delivered\&. 
.PP
\fBParameters\fP
.RS 4
\fIpszKey\fP The Topic string 
.br
\fInKeyLenght\fP The size of the topic string in bytes 
.br
\fImessage\fP the atomicx::message structure with message and tag
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one thread has received a message 
.RE
.PP

.SS "virtual void thread::atomicx::run (void)\fC [pure virtual]\fP, \fC [noexcept]\fP"

.PP
The pure virtual function that runs the thread loop\&. 
.PP
\fBNote\fP
.RS 4
REQUIRED implementation and once it returns it will execute finish method 
.RE
.PP

.SS "template<typename T > size_t thread::atomicx::SafeNotify (size_t & nMessage, T & refVar, size_t nTag = \fC0\fP, \fBNotifyType\fP notifyAll = \fC\fBNotifyType::one\fP\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Safely notify all Waits from a specific reference pointer along with a message without triggering context change\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fInMessage\fP The size_t message to be sent 
.br
\fIrefVar\fP The reference pointer used a a notifier 
.br
\fInTag\fP The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless 
.br
\fInotifyAll\fP default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified\&. 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one got notified, otherwise false\&. 
.RE
.PP

.SS "template<typename T > size_t thread::atomicx::SafeNotify (T & refVar, size_t nTag = \fC0\fP, \fBNotifyType\fP notifyAll = \fC\fBNotifyType::one\fP\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Safely notify all Waits from a specific reference pointer without triggering context change\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrefVar\fP The reference pointer used a a notifier 
.br
\fInTag\fP The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless 
.br
\fInotifyAll\fP default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified\&. 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one got notified, otherwise false\&. 
.RE
.PP

.SS "bool thread::atomicx::SafePublish (const char * pszKey, size_t nKeyLenght)\fC [protected]\fP"

.PP
Safely Publish a notification for a specific topic string DO NOT trigger a context change if any delivered\&. 
.PP
\fBParameters\fP
.RS 4
\fIpszKey\fP The Topic string 
.br
\fInKeyLenght\fP The size of the topic string in bytes
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one thread has received a message
.RE
.PP
\fBNote\fP
.RS 4
Ideal for been used with interrupt request 
.RE
.PP

.SS "bool thread::atomicx::SafePublish (const char * pszKey, size_t nKeyLenght, const \fBMessage\fP message)\fC [protected]\fP"

.PP
Safely Publish a message for a specific topic string DO NOT trigger a context change if any delivered\&. 
.PP
\fBParameters\fP
.RS 4
\fIpszKey\fP The Topic string 
.br
\fInKeyLenght\fP The size of the topic string in bytes 
.br
\fImessage\fP the atomicx::message structure with message and tag
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one thread has received a message
.RE
.PP
\fBNote\fP
.RS 4
Ideal for been used with interrupt request 
.RE
.PP

.SS "void thread::atomicx::SetDynamicNice (bool status)"

.PP
Set the Dynamic Nice on and off\&. 
.PP
\fBParameters\fP
.RS 4
\fIstatus\fP True for on otherwsize off 
.RE
.PP

.SS "void thread::atomicx::SetNice (\fBatomicx_time\fP nice)"

.PP
Set the Nice of the thread\&. 
.PP
\fBParameters\fP
.RS 4
\fInice\fP in atomicx_time reference based on the ported tick granularity 
.RE
.PP

.SS "void thread::atomicx::SetStackIncreasePace (size_t nIncreasePace)\fC [protected]\fP"

.PP
Set the Stack Increase Pace object\&. 
.PP
\fBParameters\fP
.RS 4
\fInIncreasePace\fP The new stack increase pace value 
.RE
.PP

.SS "virtual void thread::atomicx::StackOverflowHandler (void)\fC [pure virtual]\fP, \fC [noexcept]\fP"

.PP
Handles the StackOverflow of the current thread\&. 
.PP
\fBNote\fP
.RS 4
REQUIRED 
.RE
.PP

.SS "bool thread::atomicx::Start (void)\fC [static]\fP"

.PP
Once it is call the process blocks execution and start all threads\&. 
.PP
\fBReturns\fP
.RS 4
false if it was destried by dead lock (all threads locked) 
.RE
.PP

.SS "template<typename T > size_t thread::atomicx::SyncNotify (size_t && nMessage, T & refVar, size_t nTag = \fC0\fP, \fBatomicx_time\fP waitForWaitings = \fC0\fP, \fBNotifyType\fP notifyAll = \fC\fBNotifyType::one\fP\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.SS "template<typename T > size_t thread::atomicx::SyncNotify (size_t & nMessage, T & refVar, size_t nTag = \fC0\fP, \fBatomicx_time\fP waitForWaitings = \fC0\fP, \fBNotifyType\fP notifyAll = \fC\fBNotifyType::one\fP\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
SYNC Waits for at least one Wait call for a given reference pointer along with a message and trigger context change\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fInMessage\fP The size_t message to be sent 
.br
\fIrefVar\fP The reference pointer used a a notifier 
.br
\fInTag\fP The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless 
.br
\fIwaitForWaitings\fP default=0 (waiting for Waiting calls) othersize wait for Wait commands compatible with the paramenters (Sync call)\&. 
.br
\fInotifyAll\fP default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified\&. 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one got notified, otherwise false\&. 
.RE
.PP

.SS "template<typename T > size_t thread::atomicx::SyncNotify (T & refVar, size_t nTag, \fBatomicx_time\fP waitForWaitings = \fC0\fP, \fBNotifyType\fP notifyAll = \fC\fBNotifyType::one\fP\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
SYNC Waits for at least one Wait call for a given reference pointer and trigger context change\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrefVar\fP The reference pointer used a a notifier 
.br
\fInTag\fP The size_t tag that will give meaning to the notification, if nTag == 0 means notify all refVar regardless 
.br
\fIwaitForWaitings\fP default=0 (waiting for Waiting calls) othersize wait for Wait commands compatible with the paramenters (Sync call)\&. 
.br
\fInotifyAll\fP default = false, and only the fist available refVar Waiting thread will be notified, if true all available refVar waiting thread will be notified\&. 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait
.RE
.PP
\fBReturns\fP
.RS 4
true if at least one got notified, otherwise false\&. 
.RE
.PP

.SS "template<typename T > bool thread::atomicx::Wait (size_t & nMessage, T & refVar, size_t nTag = \fC0\fP, \fBatomicx_time\fP waitFor = \fC0\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Blocks/Waits a notification along with a message and tag from a specific reference pointer\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fInMessage\fP the size_t message to be received 
.br
\fIrefVar\fP the reference pointer used as a notifier 
.br
\fInTag\fP the size_t tag that will give meaning to the the message, if nTag == 0 means wait all refVar regardless 
.br
\fIwaitFor\fP default==0 (undefinitly), How log to wait for a notification based on atomicx_time 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait 
.RE
.PP
\fBReturns\fP
.RS 4
true if it was successfully received\&. 
.RE
.PP

.SS "template<typename T > bool thread::atomicx::Wait (T & refVar, size_t nTag = \fC0\fP, \fBatomicx_time\fP waitFor = \fC0\fP, \fBaSubTypes\fP asubType = \fC\fBaSubTypes::wait\fP\fP)\fC [inline]\fP, \fC [protected]\fP"

.PP
Blocks/Waits a notification along with a tag from a specific reference pointer\&. 
.PP
\fBTemplate Parameters\fP
.RS 4
\fIT\fP Type of the reference pointer 
.RE
.PP
\fBParameters\fP
.RS 4
\fIrefVar\fP the reference pointer used as a notifier 
.br
\fInTag\fP the size_t tag that will give meaning to the the message, if nTag == 0 means wait all refVar regardless 
.br
\fIwaitFor\fP default==0 (undefinitly), How log to wait for a notification based on atomicx_time 
.br
\fIasubType\fP Type of the notification, only use it if you know what you are doing, it creates a different type of wait/notify, deafault == aSubType::wait
.RE
.PP
\fBReturns\fP
.RS 4
true if it was successfully received\&. 
.RE
.PP

.SS "bool thread::atomicx::WaitBrokerMessage (const char * pszKey, size_t nKeyLenght)\fC [protected]\fP"

.PP
Block and wait for a notification from a specific topic string\&. 
.PP
\fBParameters\fP
.RS 4
\fIpszKey\fP The Topic string 
.br
\fInKeyLenght\fP The size of the topic string in bytes
.RE
.PP
\fBReturns\fP
.RS 4
true if it was successfully received, otherwise false 
.RE
.PP

.SS "bool thread::atomicx::WaitBrokerMessage (const char * pszKey, size_t nKeyLenght, \fBMessage\fP & message)\fC [protected]\fP"

.PP
Block and wait for message from a specific topic string\&. 
.PP
 
.SS "SMART BROKER IMPLEMENTATION"
\fBParameters\fP
.RS 4
\fIpszKey\fP The Topic string 
.br
\fInKeyLenght\fP The size of the topic string in bytes 
.br
\fImessage\fP the atomicx::message structure with message and tag
.RE
.PP
\fBReturns\fP
.RS 4
true if it was successfully received, otherwise false 
.RE
.PP

.SS "bool thread::atomicx::Yield (\fBatomicx_time\fP nSleep = \fC\fBATOMICX_TIME_MAX\fP\fP)"

.PP
Foce the context change explicitly\&. 
.PP
\fBParameters\fP
.RS 4
\fInSleep\fP default is ATOMICX_TIME_MAX, otherwise it will override the nice and sleep for n custom tick granularity
.RE
.PP
\fBReturns\fP
.RS 4
true if the context came back correctly, otherwise false 
.RE
.PP

.SS "void thread::atomicx::YieldNow (void)"

.PP
Trigger a high priority NOW, caution it will always execute before normal yield\&. 
.SH "Field Documentation"
.PP 
.SS "bool thread::atomicx::autoStack"

.SS "bool thread::atomicx::dynamicNice"


.SH "Author"
.PP 
Generated automatically by Doxygen for AtomicX from the source code\&.
