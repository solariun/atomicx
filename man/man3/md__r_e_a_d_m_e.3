.TH "md__r_e_a_d_m_e" 3 "Sun Jan 30 2022" "CorePartition" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md__r_e_a_d_m_e \- AtomicX 
Version 1\&.2\&.1 release
.PP
.PP
What is AtomicX? AtomicX is a general purpose \fBcooperative\fP thread lib for embedded applications (single core or confined within other RTOS) that allows you partition your application 'context' (since core execution) into several controlled context using cooperative thread\&. So far here nothing out of the ordinary, right? Lets think again:
.SH "Backlog and updates"
.PP
.SS "Implementations from Work on progress"
.SS "Version 1\&.2\&.1"
.IP "\(bu" 2
Adding Dynamic Nice, now it is possible to let the kernel set the best performance for your thread, for this \fCSetNice(*initial nice*)\fP and than \fCSetDynamicNice(true)\fP in the constructor of your thread\&. The kernel will be able to always adjust your thread for Best performance, but, it will leave no room for sleeps between threads, increasing power consumption, it is powerful but use it carefully\&.
.IP "\(bu" 2
Added \fCYieldNow()\fP the higher priority context change, it will allow other threads to work, but will, also return faster than others
.IP "\(bu" 2
**\fCsmartSemaphore\fP**, Used to compliance with RII, once used in the thread context, it takes a semaphore to be initialized and expose the same methods, although it manages the local context, and ones it it gets out of context, due to leaving {} or a functions, for example the semaphore shared context is released if ever taken during the smartSemaphore instantiated object life cycle\&. The same is available for \fCmutex\fP, called \fCsmartMutex\fP, follows the same principle\&.
.IP "\(bu" 2
\fBIMPORTANT\fP, Introducing Semaphores, \fCatomicx::semaphore(<How many shared>)\fP, now you can use methods (\fCacquire()\fP or \fCacquire(timeout)\fP) and \fCrelease()\fP along with \fCGetCount\fP, \fCGetMaxAcquired\fP, \fCGetWaitCount\fP and static method \fCGetMax\fP to return the maximum shared you can use to instantiate\&. Examples for Arduino and PC where also introduced and fully tested\&.
.IP "\(bu" 2
Introducing \fCatomicx::Timeout\fP, this will help tracking a timeout over time, using methods \fCIsTimedout\fP and \fCGetRemaining\fP and \fCGetDurationSince\fP\&. Special use case, if the timeout value is zero, IsTimedout will always return false\&.
.IP "\(bu" 2
\fBIMPORTANT NOTIFICATION\fP \fCatomicx::lock\fP has been renamed to \fCatomicx::mutex\fP for consistency, all methods are the same\&.
.IP "\(bu" 2
\fBImprovement\fP Added a contructor for self-manager start to define a start size and increase pace\&. For example: a thread starts with 150 bytes and increase pace of 10, but used stack was 200, the kernel will do 200 + 10 (increase pace) to give it room to work\&. The default value is (1) 
.PP
.nf

atomicx(size_t nStackSize, int nStackIncreasePace=1);

.fi
.PP

.PP
.SS "Version 1\&.2\&.0"
.IP "\(bu" 2
\fBINTRODUCING\fP Self managed stack, now it is possible to have self-managed stack memory for any threads, no need to define stack size\&.\&.\&. (although use it with care) just by not providing a stack memory, AtomicX will automatically switch the tread to self-managed, to do just use atomicx() default constructor instead\&.
.PP
\fINotes\fP:
.IP "  \(bu" 4
It will only entries the stack enough to hold what is needed if the used stack is greater than the stack memory managed\&.
.IP "  \(bu" 4
No decrease of the stack size was added to this release\&.
.IP "  \(bu" 4
In case your thread is not able to resize the stack, if it needs more, StackOverflowHandle is called\&.
.PP

.PP
.PP
\fIExamples:\fP
.IP "\(bu" 2
Ardunino/Simple
.IP "\(bu" 2
avrAutoRobotController
.PP
.PP
Explicitly added the pc example shown here to to examples/pc as simple along with makefile for it\&. Also updated it to have an example of Self-managed stack memory as well\&.
.SS "Version 1\&.1\&.3"
.IP "\(bu" 2
Added a Thermal Camera Demo ported from CorePartition but now fully object oriented
.IP "\(bu" 2
\fBPOWERFUL\fP: Now \fCWait\fP`Notify` will accept a new parameter called subType, the name gives no clue but it is really powerfull it allows developer to create custom Types of notifications, that same strategy is used when syncNotify is called and get blocked until a timeout occur or a wait functions is used by another thread\&.
.PP
.SS "Version 1\&.1\&.2"
.IP "\(bu" 2
**Important* \fCNotify\fP was split into \fCNotify\fP and \fCSyncNotify\fP to avoid compilation ambiguity reported for some boards, all the examples have been migrated to use one of those accordingly and tested against all supported processors\&.
.PP
.SS "Version 1\&.1\&.1"
.IP "\(bu" 2
\fIPLEASE NOTE\fP \fBNo Spin Lock what so ever in this Kernel\fP, it is working fully based on Notification event along with message transportation\&.
.IP "\(bu" 2
\fCNOTIFY\fP are now able to sync, if a atomicx_time is provided, Notify will wait for a specific signal to inform a \fCWait\fP for refVar/Tag is up\&. This is a important feature toward using WAIT/Notify reliably, while your thread can do other stuffs on idle moment
.IP "\(bu" 2
\fCavrRobotController\fP simulator for Arduino, is introduced, to show real inter process communication, it will open a terminal and both commands are available: \fCsystem\fP - To show Memory, Threads and motor status and \fCmove <flot motor A> <flot motor B> <flot motor C>\fP
.PP
.SS "Version 1\&.1\&.0"
.IP "\(bu" 2
\fCfinish()\fP method will be call every time \fCrun()\fP is returned, this allow special cases like eventual threads to self-destroy itself, otherwise the object would be only a memory leak\&.\&.\&.\&. see examples on \fC\fBmain\&.cpp\fP\fP
.IP "\(bu" 2
\fCsmartMutex\fP RAII compliance, allow mutex or shared mutex to be auto release on object destruction\&.
.IP "\(bu" 2
\fBIMPORTANT\fP Now Notifications (Wait/Notify) can be timedout\&. if Tick based time is given, the waiting procedure will only stay blocked during it\&. (NO SPIN LOCK, REAL STATE BLOCK)
.IP "\(bu" 2
\fBIMPORTANT\fP \fCLookForWaitings\fP block for timeout time will a wait for specific refVar/tag is available, otherwise timeout, can be used sync wait and notify availability
.IP "\(bu" 2
\fBIMPORTANT\fP Now \fCWait/Notify\fP \fCTags\fP, used to give meaning/channel to a notification can be se to 'all tags' if \fCTag\fP is zero, otherwise it will respect refVar/Tag
.PP
.SS "Version 1\&.0\&.0"
.IP "\(bu" 2
\fBDOES NOT DISPLACE STACK, IT WILL STILL AVAILABLE FOR PROCESSING\fP, the \fIStack Page\fP will only hold a backup of the most necessary information needed, allowing stacks in few bites most if the time\&. This implementation if highly suitable for Microcontrollers like ATINY85, for example, that only has 512 bites, and you can have 5 or more threads doing things for you, only backup the most important context information\&.
.IP "  \(bu" 4
\fIIMPORTANT\fP: DO NOT USE CONTEXT MEMORY POINTER to exchange information to other threads, wait/notify and etc\&. All threads will use the \fIdafault stack memory\fP to execute, instead use Global variables, allocated memory or atomicx_smart_ptr objects\&.
.PP

.IP "\(bu" 2
Since it implements Cooperative thread every execution will atomic between \fIatomicx\fP thrteads\&.
.IP "\(bu" 2
AtomicX \fBDOES NOT DISPLACE STACK\fP, yes, it will use a novel technique that allow you to use full stack memory freely, and once done, just call \fCYield()\fP to switch the context\&.
.IP "  1." 6
Allow you to use all your stack during thread execution and only switch once back to an appropriate place 
.PP
.nf
Stack memory
*-----------*
|___________| Yield()
|___________|    thread 0\&.\&.N
|___________|     |       \&.  - After context execution
|___________|     |      /|\   is done, the developer can
|___________|     |       |    choose where to switch
|___________|     |       |    context, saving only what is
|___________|    \|/      |    necessary
|___________|     ---------
|           |     - During context
*-----------*       can goes deeper as
                    necessary

.fi
.PP

.PP

.IP "\(bu" 2
Due to the \fBzero stack-displacement\fP technology, developers can ensure minimal stack memory page, allowing ultra sophisticated designes and execution stack diving and only backing up to the stack memory page what is necessary\&.
.IP "\(bu" 2
Full feature for IPC (\fIInter Process Communication\fP)
.IP "  \(bu" 4
\fBThread\fP safe Queues for data/object transporting\&.
.IP "  \(bu" 4
EVERY Smart Lock can transport information (atomicx::message)
.IP "  \(bu" 4
Message is composed by 'size_t `atomix::message` and a 'size_t tag'
        * This novel concept of 'tag's for an atomicx::message gives the message meaning\&.
        * Since <tt>atomicx::message</tt> uses <tt>size_t</tt> messages can also transport pointers
    * Smart Locks can Lock and Shared Lock in the same object, making
    * Full QUEUE capable to transport objects\&.

* Full feature for IPN (<em>Inter Process Notification</em>)
    * Thread can wait for an event to happen\&.
    * On event notification a <tt>atomix::message</tt> can be sent/received

* A message broker based on observer pattern
    * A thread can use <tt>WaitBroker Message</tt> to wait for any specifc topic asynchronously\&.
    * Instead of having a <tt>Subcrib</tt> call, the developer will provide a <tt>IsSubscribed</tt> method that the kernel will use to determine if the object/thread is subscribed to a given topic\&.
    * Broker uses <tt>atomicx::message</tt> to transport information\&. For inter process Object transport, please use atomicx::queue\&.

* ALL <em>WAIT</em> actions will block the thread, on kernel level (setting thread to a waiting state), until the notification occurs\&. Alternatively the notification can be transport a <tt>atomicx::message</tt> structure (tag/message)
    * <em>WAIT</em> and <em>NOTIFY</em> (one or all) will use <em>any pointer</em> as the signal input, virtually any valid address pointer can  be used\&. <em>IMPORTANT</em>: Unless you know what you are doing, do <em>NOT</em> use context pointer (execution stack memory), use a global or allocated memory instead (including <tt>atomicx::smart_prt</tt>)

* All <em>Notifications</em> or <em>Publish</em> functions will provide a Safe version, that different from the pure functions, will not trigger a context change and the function will only fully take effect onces the context is changed in the current thread where the interrupt request happened\&.

* <strong>IMPORTANT</strong> since all threads will be executed in the '_default_' stack memory, it will not be jailed in the stack size memory page, <em>DO NOT USE STACK ADDRESS TO COMMUNICATE</em> with another threads, use only global or alloced memory pointers to communicate

* <strong>IMPORTANT</strong> In order to operate with precision, specialise ticks by providing either <tt>atomicx_time Atomicx_GetTick (void)</tt> and <tt>void Atomicx_SleepTick(atomicx_time nSleep)</tt> to work within the timeframe (milleseconds, nanoseconds, seconds\&.\&. etc)\&. Since AtomicX, also, provice, Sleep Tick functionality (to handle idle time), depending on the sleep time, to developer can redude the processor overall consuption to minimal whenever it is not necessary\&.

    * Since it will be provided by the developer, it gives the possibility to use external clocks, hardware sleep or lower consumptions and fine tune power and resource usages\&.

    * If not specialization is done, the source code will use a simple and non-deterministic loop cycle to count ticks\&.


@code 
//
//  main\&.cpp
//  atomicx
//
//  Created by GUSTAVO CAMPOS on 28/08/2021\&.
//

#include <unistd\&.h>
#include <sys/time\&.h>
#include <unistd\&.h>

#include <cstring>
#include <cstdint>
#include <iostream>
#include <setjmp\&.h>
#include <string>

#include 'atomicx\&.hpp'

using namespace thread;

#ifdef FAKE_TIMER
uint nCounter=0;
#endif

void ListAllThreads();

/*
 * Define the default ticket granularity
 * to milliseconds or round tick if -DFAKE_TICKER
 * is provided on compilation
 */
atomicx_time Atomicx_GetTick (void)
{
#ifndef FAKE_TIMER
    usleep (20000);
    struct timeval tp;
    gettimeofday (&tp, NULL);

    return (atomicx_time)tp\&.tv_sec * 1000 + tp\&.tv_usec / 1000;
#else
    nCounter++;

    return nCounter;
#endif
}

/*
 * Sleep for few Ticks, since the default ticket granularity
 * is set to Milliseconds (if -DFAKE_TICKET provide will it will
 * be context switch countings), the thread will sleep for
 * the amount of time needed till next thread start\&.
 */
void Atomicx_SleepTick(atomicx_time nSleep)
{
#ifndef FAKE_TIMER
    usleep ((useconds_t)nSleep * 1000);
#else
    while (nSleep); usleep(100);
#endif
}

/*
 * Object that implements thread with self-managed (dynamic) stack size
 */
class SelfManagedThread : public atomicx
{
public:
    SelfManagedThread(atomicx_time nNice) : atomicx()
    {
        SetNice(nNice);
    }

    ~SelfManagedThread()
    {
        std::cout << 'Deleting ' << GetName() << ': ' << (size_t) this << std::endl;
    }

    void run() noexcept override
    {
        size_t nCount=0;

        do
        {
            std::cout << __FUNCTION__ << ', Executing ' << GetName() << ': ' << (size_t) this << ', Counter: ' << nCount << std::endl << std::flush;

            nCount++;

        }  while (Yield());

    }

    void StackOverflowHandler (void) noexcept override
    {
        std::cout << __FUNCTION__ << ':' << GetName() << '_' << (size_t) this << ': needed: ' << GetUsedStackSize() << ', allocated: ' << GetStackSize() << std::endl;
    }

    const char* GetName (void) override
    {
        return 'Self-Managed \fBThread\fP';
    }
};

/*
 * Object that implements thread
 */
class Thread : public atomicx
{
public:
    Thread(atomicx_time nNice) : atomicx(stack)
    {
        SetNice(nNice);
    }

    ~Thread()
    {
        std::cout << 'Deleting ' << GetName() << ': ' << (size_t) this << std::endl;
    }

    void run() noexcept override
    {
        size_t nCount=0;

        do
        {
            std::cout << __FUNCTION__ << ', Executing ' << GetName() << ': ' << (size_t) this << ', Counter: ' << nCount << std::endl << std::flush;

            nCount++;

        }  while (Yield());

    }

    void StackOverflowHandler (void) noexcept override
    {
        std::cout << __FUNCTION__ << ':' << GetName() << '_' << (size_t) this << ': needed: ' << GetUsedStackSize() << ', allocated: ' << GetStackSize() << std::endl;
    }

    const char* GetName (void) override
    {
        return '\fBThread\fP';
    }

private:
    uint8_t stack[1024]='"; //Static initialization to avoid initialization order problem };
.PP

.PP
.PP
int \fBmain()\fP { \fBThread\fP t1(200); \fBThread\fP t2(500);
.PP
SelfManagedThread st1(200);
.PP
// This must creates threads and destroy on leaving {} context { \fBThread\fP t3_1(0); \fBThread\fP t3_2(0); \fBThread\fP t3_3(0);
.PP
// since those objects will be destroied here // they should never start and AtomicX should // transparently clean it from the execution list }
.PP
\fBThread\fP t4(1000);
.PP
atomicx::Start(); }
