Version 1.\+2.\+1 release



What is AtomicX? AtomicX is a general purpose {\bfseries{cooperative}} thread lib for embedded applications (single core or confined within other RTOS) that allows you partition your application \char`\"{}context\char`\"{} (since core execution) into several controlled context using cooperative thread. So far here nothing out of the ordinary, right? Lets think again\+:\hypertarget{md__r_e_a_d_m_e_autotoc_md60}{}\doxysection{Backlog and updates}\label{md__r_e_a_d_m_e_autotoc_md60}
\hypertarget{md__r_e_a_d_m_e_autotoc_md61}{}\doxysubsection{Implementations from Work on progress}\label{md__r_e_a_d_m_e_autotoc_md61}
\hypertarget{md__r_e_a_d_m_e_autotoc_md62}{}\doxysubsection{Version 1.\+2.\+1}\label{md__r_e_a_d_m_e_autotoc_md62}

\begin{DoxyItemize}
\item Adding Dynamic Nice, now it is possible to let the kernel set the best performance for your thread, for this {\ttfamily Set\+Nice($\ast$initial nice$\ast$)} and than {\ttfamily Set\+Dynamic\+Nice(true)} in the constructor of your thread. The kernel will be able to always adjust your thread for Best performance, but, it will leave no room for sleeps between threads, increasing power consumption, it is powerful but use it carefully.
\item Added {\ttfamily Yield\+Now()} the higher priority context change, it will allow other threads to work, but will, also return faster than others
\item $\ast$$\ast${\ttfamily smart\+Semaphore}$\ast$$\ast$, Used to compliance with RII, once used in the thread context, it takes a semaphore to be initialized and expose the same methods, although it manages the local context, and ones it it gets out of context, due to leaving \{\} or a functions, for example the semaphore shared context is released if ever taken during the smart\+Semaphore instantiated object life cycle. The same is available for {\ttfamily mutex}, called {\ttfamily smart\+Mutex}, follows the same principle.
\item {\bfseries{IMPORTANT}}, Introducing Semaphores, {\ttfamily atomicx\+::semaphore(\texorpdfstring{$<$}{<}How many shared\texorpdfstring{$>$}{>})}, now you can use methods ({\ttfamily acquire()} or {\ttfamily acquire(timeout)}) and {\ttfamily release()} along with {\ttfamily Get\+Count}, {\ttfamily Get\+Max\+Acquired}, {\ttfamily Get\+Wait\+Count} and static method {\ttfamily Get\+Max} to return the maximum shared you can use to instantiate. Examples for Arduino and PC where also introduced and fully tested.
\item Introducing {\ttfamily atomicx\+::\+Timeout}, this will help tracking a timeout over time, using methods {\ttfamily Is\+Timedout} and {\ttfamily Get\+Remaining} and {\ttfamily Get\+Duration\+Since}. Special use case, if the timeout value is zero, Is\+Timedout will always return false.
\item {\bfseries{IMPORTANT NOTIFICATION}} {\ttfamily atomicx\+::lock} has been renamed to {\ttfamily atomicx\+::mutex} for consistency, all methods are the same.
\item {\bfseries{Improvement}} Added a contructor for self-\/manager start to define a start size and increase pace. For example\+: a thread starts with 150 bytes and increase pace of 10, but used stack was 200, the kernel will do 200 + 10 (increase pace) to give it room to work. The default value is (1) 
\begin{DoxyCode}{0}
\DoxyCodeLine{}
\DoxyCodeLine{atomicx(\textcolor{keywordtype}{size\_t} nStackSize, \textcolor{keywordtype}{int} nStackIncreasePace=1);}

\end{DoxyCode}

\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md63}{}\doxysubsection{Version 1.\+2.\+0}\label{md__r_e_a_d_m_e_autotoc_md63}

\begin{DoxyItemize}
\item {\bfseries{INTRODUCING}} Self managed stack, now it is possible to have self-\/managed stack memory for any threads, no need to define stack size... (although use it with care) just by not providing a stack memory, AtomicX will automatically switch the tread to self-\/managed, to do just use atomicx() default constructor instead.

{\itshape Notes}\+:
\begin{DoxyItemize}
\item It will only entries the stack enough to hold what is needed if the used stack is greater than the stack memory managed.
\item No decrease of the stack size was added to this release.
\item In case your thread is not able to resize the stack, if it needs more, Stack\+Overflow\+Handle is called.
\end{DoxyItemize}
\end{DoxyItemize}

{\itshape Examples\+:}
\begin{DoxyItemize}
\item Ardunino/\+Simple
\item avr\+Auto\+Robot\+Controller
\end{DoxyItemize}

Explicitly added the pc example shown here to to examples/pc as simple along with makefile for it. Also updated it to have an example of Self-\/managed stack memory as well.\hypertarget{md__r_e_a_d_m_e_autotoc_md64}{}\doxysubsection{Version 1.\+1.\+3}\label{md__r_e_a_d_m_e_autotoc_md64}

\begin{DoxyItemize}
\item Added a Thermal Camera Demo ported from Core\+Partition but now fully object oriented
\item {\bfseries{POWERFUL}}\+: Now {\ttfamily Wait}\`{}\+Notify\`{} will accept a new parameter called sub\+Type, the name gives no clue but it is really powerfull it allows developer to create custom Types of notifications, that same strategy is used when sync\+Notify is called and get blocked until a timeout occur or a wait functions is used by another thread.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md65}{}\doxysubsection{Version 1.\+1.\+2}\label{md__r_e_a_d_m_e_autotoc_md65}

\begin{DoxyItemize}
\item $\ast$$\ast$\+Important$\ast$ {\ttfamily Notify} was split into {\ttfamily Notify} and {\ttfamily Sync\+Notify} to avoid compilation ambiguity reported for some boards, all the examples have been migrated to use one of those accordingly and tested against all supported processors.
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md66}{}\doxysubsection{Version 1.\+1.\+1}\label{md__r_e_a_d_m_e_autotoc_md66}

\begin{DoxyItemize}
\item {\itshape PLEASE NOTE} {\bfseries{No Spin Lock what so ever in this Kernel}}, it is working fully based on Notification event along with message transportation.
\item {\ttfamily NOTIFY} are now able to sync, if a atomicx\+\_\+time is provided, Notify will wait for a specific signal to inform a {\ttfamily Wait} for ref\+Var/\+Tag is up. This is a important feature toward using WAIT/\+Notify reliably, while your thread can do other stuffs on idle moment
\item {\ttfamily avr\+Robot\+Controller} simulator for Arduino, is introduced, to show real inter process communication, it will open a terminal and both commands are available\+: {\ttfamily system} -\/ To show Memory, Threads and motor status and {\ttfamily move \texorpdfstring{$<$}{<}flot motor A\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}flot motor B\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}flot motor C\texorpdfstring{$>$}{>}}
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md67}{}\doxysubsection{Version 1.\+1.\+0}\label{md__r_e_a_d_m_e_autotoc_md67}

\begin{DoxyItemize}
\item {\ttfamily finish()} method will be call every time {\ttfamily run()} is returned, this allow special cases like eventual threads to self-\/destroy itself, otherwise the object would be only a memory leak.... see examples on {\ttfamily \mbox{\hyperlink{main_8cpp}{main.\+cpp}}}
\item {\ttfamily smart\+Mutex} RAII compliance, allow mutex or shared mutex to be auto release on object destruction.
\item {\bfseries{IMPORTANT}} Now Notifications (Wait/\+Notify) can be timedout. if Tick based time is given, the waiting procedure will only stay blocked during it. (NO SPIN LOCK, REAL STATE BLOCK)
\item {\bfseries{IMPORTANT}} {\ttfamily Look\+For\+Waitings} block for timeout time will a wait for specific ref\+Var/tag is available, otherwise timeout, can be used sync wait and notify availability
\item {\bfseries{IMPORTANT}} Now {\ttfamily Wait/\+Notify} {\ttfamily Tags}, used to give meaning/channel to a notification can be se to \char`\"{}all tags\char`\"{} if {\ttfamily Tag} is zero, otherwise it will respect ref\+Var/\+Tag
\end{DoxyItemize}\hypertarget{md__r_e_a_d_m_e_autotoc_md68}{}\doxysubsection{Version 1.\+0.\+0}\label{md__r_e_a_d_m_e_autotoc_md68}

\begin{DoxyItemize}
\item {\bfseries{DOES NOT DISPLACE STACK, IT WILL STILL AVAILABLE FOR PROCESSING}}, the {\itshape Stack Page} will only hold a backup of the most necessary information needed, allowing stacks in few bites most if the time. This implementation if highly suitable for Microcontrollers like ATINY85, for example, that only has 512 bites, and you can have 5 or more threads doing things for you, only backup the most important context information.
\begin{DoxyItemize}
\item {\itshape IMPORTANT}\+: DO NOT USE CONTEXT MEMORY POINTER to exchange information to other threads, wait/notify and etc. All threads will use the {\itshape dafault stack memory} to execute, instead use Global variables, allocated memory or atomicx\+\_\+smart\+\_\+ptr objects.
\end{DoxyItemize}
\item Since it implements Cooperative thread every execution will atomic between {\itshape atomicx} thrteads.
\item AtomicX {\bfseries{DOES NOT DISPLACE STACK}}, yes, it will use a novel technique that allow you to use full stack memory freely, and once done, just call {\ttfamily Yield()} to switch the context.
\begin{DoxyEnumerate}
\item Allow you to use all your stack during thread execution and only switch once back to an appropriate place 
\begin{DoxyCode}{0}
\DoxyCodeLine{Stack memory}
\DoxyCodeLine{*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*}
\DoxyCodeLine{|\_\_\_\_\_\_\_\_\_\_\_| Yield()}
\DoxyCodeLine{|\_\_\_\_\_\_\_\_\_\_\_|    thread 0..N}
\DoxyCodeLine{|\_\_\_\_\_\_\_\_\_\_\_|     |       .  -\/ After context execution}
\DoxyCodeLine{|\_\_\_\_\_\_\_\_\_\_\_|     |      /|\(\backslash\)   is done, the developer can}
\DoxyCodeLine{|\_\_\_\_\_\_\_\_\_\_\_|     |       |    choose where to switch}
\DoxyCodeLine{|\_\_\_\_\_\_\_\_\_\_\_|     |       |    context, saving only what is}
\DoxyCodeLine{|\_\_\_\_\_\_\_\_\_\_\_|    \(\backslash\)|/      |    necessary}
\DoxyCodeLine{|\_\_\_\_\_\_\_\_\_\_\_|     -\/-\/-\/-\/-\/-\/-\/-\/-\/}
\DoxyCodeLine{|           |     -\/ During context}
\DoxyCodeLine{*-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/*       can goes deeper as}
\DoxyCodeLine{                    necessary}

\end{DoxyCode}

\end{DoxyEnumerate}
\item Due to the {\bfseries{zero stack-\/displacement}} technology, developers can ensure minimal stack memory page, allowing ultra sophisticated designes and execution stack diving and only backing up to the stack memory page what is necessary.
\item Full feature for IPC ({\itshape Inter Process Communication})
\begin{DoxyItemize}
\item \mbox{\hyperlink{class_thread}{Thread}} safe Queues for data/object transporting.
\item EVERY Smart Lock can transport information (atomicx\+::message)
\item Message is composed by \char`\"{}size\+\_\+t \`{}atomix\+::message\`{} and a \char`\"{}size\+\_\+t tag\char`\"{}         $\ast$ This novel concept of \char`\"{}tag\char`\"{}s for an atomicx\+::message gives the message meaning.         $\ast$ Since $<$tt$>$atomicx\+::message$<$/tt$>$ uses $<$tt$>$size\+\_\+t$<$/tt$>$ messages can also transport pointers     $\ast$ Smart Locks can Lock and Shared Lock in the same object, making     $\ast$ Full QUEUE capable to transport objects.  $\ast$ Full feature for IPN ($<$em$>$\+Inter Process Notification$<$/em$>$)     $\ast$ Thread can wait for an event to happen.     $\ast$ On event notification a $<$tt$>$atomix\+::message$<$/tt$>$ can be sent/received  $\ast$ A message broker based on observer pattern     $\ast$ A thread can use $<$tt$>$\+Wait\+Broker Message$<$/tt$>$ to wait for any specifc topic asynchronously.     $\ast$ Instead of having a $<$tt$>$\+Subcrib$<$/tt$>$ call, the developer will provide a $<$tt$>$\+Is\+Subscribed$<$/tt$>$ method that the kernel will use to determine if the object/thread is subscribed to a given topic.     $\ast$ Broker uses $<$tt$>$atomicx\+::message$<$/tt$>$ to transport information. For inter process Object transport, please use atomicx\+::queue.  $\ast$ ALL $<$em$>$\+WAIT$<$/em$>$ actions will block the thread, on kernel level (setting thread to a waiting state), until the notification occurs. Alternatively the notification can be transport a $<$tt$>$atomicx\+::message$<$/tt$>$ structure (tag/message)     $\ast$ $<$em$>$\+WAIT$<$/em$>$ and $<$em$>$\+NOTIFY$<$/em$>$ (one or all) will use $<$em$>$any pointer$<$/em$>$ as the signal input, virtually any valid address pointer can  be used. $<$em$>$\+IMPORTANT$<$/em$>$\+: Unless you know what you are doing, do $<$em$>$\+NOT$<$/em$>$ use context pointer (execution stack memory), use a global or allocated memory instead (including $<$tt$>$atomicx\+::smart\+\_\+prt$<$/tt$>$)  $\ast$ All $<$em$>$\+Notifications$<$/em$>$ or $<$em$>$\+Publish$<$/em$>$ functions will provide a Safe version, that different from the pure functions, will not trigger a context change and the function will only fully take effect onces the context is changed in the current thread where the interrupt request happened.  $\ast$ $<$strong$>$\+IMPORTANT$<$/strong$>$ since all threads will be executed in the \char`\"{}\+\_\+default\+\_\+\char`\"{} stack memory, it will not be jailed in the stack size memory page, $<$em$>$\+DO NOT USE STACK ADDRESS TO COMMUNICATE$<$/em$>$ with another threads, use only global or alloced memory pointers to communicate  $\ast$ $<$strong$>$\+IMPORTANT$<$/strong$>$ In order to operate with precision, specialise ticks by providing either $<$tt$>$atomicx\+\_\+time Atomicx\+\_\+\+Get\+Tick (void)$<$/tt$>$ and $<$tt$>$void Atomicx\+\_\+\+Sleep\+Tick(atomicx\+\_\+time n\+Sleep)$<$/tt$>$ to work within the timeframe (milleseconds, nanoseconds, seconds.. etc). Since Atomic\+X, also, provice, Sleep Tick functionality (to handle idle time), depending on the sleep time, to developer can redude the processor overall consuption to minimal whenever it is not necessary.      $\ast$ Since it will be provided by the developer, it gives the possibility to use external clocks, hardware sleep or lower consumptions and fine tune power and resource usages.      $\ast$ If not specialization is done, the source code will use a simple and non-\/deterministic loop cycle to count ticks.   @code  // //  main.\+cpp //  atomicx // //  Created by GUSTAVO CAMPOS on 28/08/2021. //  \#include $<$unistd.\+h$>$ \#include $<$sys/time.\+h$>$ \#include $<$unistd.\+h$>$  \#include $<$cstring$>$ \#include $<$cstdint$>$ \#include $<$iostream$>$ \#include $<$setjmp.\+h$>$ \#include $<$string$>$  \#include \char`\"{}\mbox{\hyperlink{atomicx_8hpp}{atomicx.\+hpp}}\char`\"{}  using namespace thread;  \#ifdef FAKE\+\_\+\+TIMER uint n\+Counter=0; \#endif  void List\+All\+Threads();  /$\ast$  $\ast$ Define the default ticket granularity  $\ast$ to milliseconds or round tick if -\/\+DFAKE\+\_\+\+TICKER  $\ast$ is provided on compilation  $\ast$/ atomicx\+\_\+time Atomicx\+\_\+\+Get\+Tick (void) \{ \#ifndef FAKE\+\_\+\+TIMER     usleep (20000);     struct timeval tp;     gettimeofday (\&tp, NULL);      return (atomicx\+\_\+time)tp.\+tv\+\_\+sec $\ast$ 1000 + tp.\+tv\+\_\+usec / 1000; \#else     n\+Counter++;      return n\+Counter; \#endif \}  /$\ast$  $\ast$ Sleep for few Ticks, since the default ticket granularity  $\ast$ is set to Milliseconds (if -\/\+DFAKE\+\_\+\+TICKET provide will it will  $\ast$ be context switch countings), the thread will sleep for  $\ast$ the amount of time needed till next thread start.  $\ast$/ void Atomicx\+\_\+\+Sleep\+Tick(atomicx\+\_\+time n\+Sleep) \{ \#ifndef FAKE\+\_\+\+TIMER     usleep ((useconds\+\_\+t)n\+Sleep $\ast$ 1000); \#else     while (n\+Sleep); usleep(100); \#endif \}  /$\ast$  $\ast$ Object that implements thread with self-\/managed (dynamic) stack size  $\ast$/ class Self\+Managed\+Thread \+: public atomicx \{ public\+:     Self\+Managed\+Thread(atomicx\+\_\+time n\+Nice) \+: atomicx()     \{         Set\+Nice(n\+Nice);     \}      $\sim$\+Self\+Managed\+Thread()     \{         std\+::cout $<$$<$ \char`\"{}Deleting \char`\"{} $<$$<$ Get\+Name() $<$$<$ \char`\"{}\+: \char`\"{} $<$$<$ (size\+\_\+t) this $<$$<$ std\+::endl;     \}      void run() noexcept override     \{         size\+\_\+t n\+Count=0;          do         \{             std\+::cout $<$$<$ \+\_\+\+\_\+\+FUNCTION\+\_\+\+\_\+ $<$$<$ \char`\"{}, Executing \char`\"{} $<$$<$ Get\+Name() $<$$<$ \char`\"{}\+: \char`\"{} $<$$<$ (size\+\_\+t) this $<$$<$ \char`\"{}, Counter\+: \char`\"{} $<$$<$ n\+Count $<$$<$ std\+::endl $<$$<$ std\+::flush;              n\+Count++;          \}  while (\+Yield());      \}      void Stack\+Overflow\+Handler (void) noexcept override     \{         std\+::cout $<$$<$ \+\_\+\+\_\+\+FUNCTION\+\_\+\+\_\+ $<$$<$ \char`\"{}\+:\char`\"{} $<$$<$ Get\+Name() $<$$<$ \char`\"{}\+\_\+\char`\"{} $<$$<$ (size\+\_\+t) this $<$$<$ \char`\"{}\+: needed\+: \char`\"{} $<$$<$ Get\+Used\+Stack\+Size() $<$$<$ \char`\"{}, allocated\+: \char`\"{} $<$$<$ Get\+Stack\+Size() $<$$<$ std\+::endl;     \}      const char$\ast$ Get\+Name (void) override     \{         return \char`\"{}Self-\/\+Managed \mbox{\hyperlink{class_thread}{Thread}}\char`\"{};     \} \};  /$\ast$  $\ast$ Object that implements thread  $\ast$/ class Thread \+: public atomicx \{ public\+:     Thread(atomicx\+\_\+time n\+Nice) \+: atomicx(stack)     \{         Set\+Nice(n\+Nice);     \}      $\sim$\+Thread()     \{         std\+::cout $<$$<$ \char`\"{}Deleting \char`\"{} $<$$<$ Get\+Name() $<$$<$ \char`\"{}\+: \char`\"{} $<$$<$ (size\+\_\+t) this $<$$<$ std\+::endl;     \}      void run() noexcept override     \{         size\+\_\+t n\+Count=0;          do         \{             std\+::cout $<$$<$ \+\_\+\+\_\+\+FUNCTION\+\_\+\+\_\+ $<$$<$ \char`\"{}, Executing \char`\"{} $<$$<$ Get\+Name() $<$$<$ \char`\"{}\+: \char`\"{} $<$$<$ (size\+\_\+t) this $<$$<$ \char`\"{}, Counter\+: \char`\"{} $<$$<$ n\+Count $<$$<$ std\+::endl $<$$<$ std\+::flush;              n\+Count++;          \}  while (\+Yield());      \}      void Stack\+Overflow\+Handler (void) noexcept override     \{         std\+::cout $<$$<$ \+\_\+\+\_\+\+FUNCTION\+\_\+\+\_\+ $<$$<$ \char`\"{}\+:\char`\"{} $<$$<$ Get\+Name() $<$$<$ \char`\"{}\+\_\+\char`\"{} $<$$<$ (size\+\_\+t) this $<$$<$ \char`\"{}\+: needed\+: \char`\"{} $<$$<$ Get\+Used\+Stack\+Size() $<$$<$ \char`\"{}, allocated\+: \char`\"{} $<$$<$ Get\+Stack\+Size() $<$$<$ std\+::endl;     \}      const char$\ast$ Get\+Name (void) override     \{         return \char`\"{}\mbox{\hyperlink{class_thread}{Thread}}\char`\"{};     \}  private\+:     uint8\+\_\+t stack\mbox{[}1024\mbox{]}=\char`\"{}"{}; //\+Static initialization to avoid initialization order problem \};
\end{DoxyItemize}
\end{DoxyItemize}

int \mbox{\hyperlink{semaphore_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4}{main()}} \{ \mbox{\hyperlink{class_thread}{Thread}} t1(200); \mbox{\hyperlink{class_thread}{Thread}} t2(500);

\mbox{\hyperlink{class_self_managed_thread}{Self\+Managed\+Thread}} st1(200);

// This must creates threads and destroy on leaving \{\} context \{ \mbox{\hyperlink{class_thread}{Thread}} t3\+\_\+1(0); \mbox{\hyperlink{class_thread}{Thread}} t3\+\_\+2(0); \mbox{\hyperlink{class_thread}{Thread}} t3\+\_\+3(0);

// since those objects will be destroied here // they should never start and AtomicX should // transparently clean it from the execution list \}

\mbox{\hyperlink{class_thread}{Thread}} t4(1000);

atomicx\+::\+Start(); \}